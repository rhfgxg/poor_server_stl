// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server_logic.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_5flogic_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_server_5flogic_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_server_5flogic_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_server_5flogic_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_server_5flogic_2eproto;
namespace rpc_server {
class AddItemReq;
struct AddItemReqDefaultTypeInternal;
extern AddItemReqDefaultTypeInternal _AddItemReq_default_instance_;
class AddItemRes;
struct AddItemResDefaultTypeInternal;
extern AddItemResDefaultTypeInternal _AddItemRes_default_instance_;
class GetPlayerAchievementsReq;
struct GetPlayerAchievementsReqDefaultTypeInternal;
extern GetPlayerAchievementsReqDefaultTypeInternal _GetPlayerAchievementsReq_default_instance_;
class GetPlayerAchievementsRes;
struct GetPlayerAchievementsResDefaultTypeInternal;
extern GetPlayerAchievementsResDefaultTypeInternal _GetPlayerAchievementsRes_default_instance_;
class GetPlayerCollectionReq;
struct GetPlayerCollectionReqDefaultTypeInternal;
extern GetPlayerCollectionReqDefaultTypeInternal _GetPlayerCollectionReq_default_instance_;
class GetPlayerCollectionRes;
struct GetPlayerCollectionResDefaultTypeInternal;
extern GetPlayerCollectionResDefaultTypeInternal _GetPlayerCollectionRes_default_instance_;
class GetPlayerTasksReq;
struct GetPlayerTasksReqDefaultTypeInternal;
extern GetPlayerTasksReqDefaultTypeInternal _GetPlayerTasksReq_default_instance_;
class GetPlayerTasksRes;
struct GetPlayerTasksResDefaultTypeInternal;
extern GetPlayerTasksResDefaultTypeInternal _GetPlayerTasksRes_default_instance_;
class SaveBattleResultReq;
struct SaveBattleResultReqDefaultTypeInternal;
extern SaveBattleResultReqDefaultTypeInternal _SaveBattleResultReq_default_instance_;
class SaveBattleResultRes;
struct SaveBattleResultResDefaultTypeInternal;
extern SaveBattleResultResDefaultTypeInternal _SaveBattleResultRes_default_instance_;
class UpdatePlayerAchievementsReq;
struct UpdatePlayerAchievementsReqDefaultTypeInternal;
extern UpdatePlayerAchievementsReqDefaultTypeInternal _UpdatePlayerAchievementsReq_default_instance_;
class UpdatePlayerAchievementsRes;
struct UpdatePlayerAchievementsResDefaultTypeInternal;
extern UpdatePlayerAchievementsResDefaultTypeInternal _UpdatePlayerAchievementsRes_default_instance_;
class UpdatePlayerCollectionReq;
struct UpdatePlayerCollectionReqDefaultTypeInternal;
extern UpdatePlayerCollectionReqDefaultTypeInternal _UpdatePlayerCollectionReq_default_instance_;
class UpdatePlayerCollectionRes;
struct UpdatePlayerCollectionResDefaultTypeInternal;
extern UpdatePlayerCollectionResDefaultTypeInternal _UpdatePlayerCollectionRes_default_instance_;
class UpdatePlayerTasksReq;
struct UpdatePlayerTasksReqDefaultTypeInternal;
extern UpdatePlayerTasksReqDefaultTypeInternal _UpdatePlayerTasksReq_default_instance_;
class UpdatePlayerTasksRes;
struct UpdatePlayerTasksResDefaultTypeInternal;
extern UpdatePlayerTasksResDefaultTypeInternal _UpdatePlayerTasksRes_default_instance_;
class UseItemReq;
struct UseItemReqDefaultTypeInternal;
extern UseItemReqDefaultTypeInternal _UseItemReq_default_instance_;
class UseItemRes;
struct UseItemResDefaultTypeInternal;
extern UseItemResDefaultTypeInternal _UseItemRes_default_instance_;
}  // namespace rpc_server
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace rpc_server {

// ===================================================================


// -------------------------------------------------------------------

class UseItemRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UseItemRes) */ {
 public:
  inline UseItemRes() : UseItemRes(nullptr) {}
  ~UseItemRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UseItemRes(::google::protobuf::internal::ConstantInitialized);

  inline UseItemRes(const UseItemRes& from)
      : UseItemRes(nullptr, from) {}
  UseItemRes(UseItemRes&& from) noexcept
    : UseItemRes() {
    *this = ::std::move(from);
  }

  inline UseItemRes& operator=(const UseItemRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseItemRes& operator=(UseItemRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseItemRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseItemRes* internal_default_instance() {
    return reinterpret_cast<const UseItemRes*>(
               &_UseItemRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UseItemRes& a, UseItemRes& b) {
    a.Swap(&b);
  }
  inline void Swap(UseItemRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseItemRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseItemRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseItemRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UseItemRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UseItemRes& from) {
    UseItemRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UseItemRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UseItemRes";
  }
  protected:
  explicit UseItemRes(::google::protobuf::Arena* arena);
  UseItemRes(::google::protobuf::Arena* arena, const UseItemRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UseItemRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class UseItemReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UseItemReq) */ {
 public:
  inline UseItemReq() : UseItemReq(nullptr) {}
  ~UseItemReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UseItemReq(::google::protobuf::internal::ConstantInitialized);

  inline UseItemReq(const UseItemReq& from)
      : UseItemReq(nullptr, from) {}
  UseItemReq(UseItemReq&& from) noexcept
    : UseItemReq() {
    *this = ::std::move(from);
  }

  inline UseItemReq& operator=(const UseItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseItemReq& operator=(UseItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseItemReq* internal_default_instance() {
    return reinterpret_cast<const UseItemReq*>(
               &_UseItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UseItemReq& a, UseItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UseItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseItemReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseItemReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseItemReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UseItemReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UseItemReq& from) {
    UseItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UseItemReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UseItemReq";
  }
  protected:
  explicit UseItemReq(::google::protobuf::Arena* arena);
  UseItemReq(::google::protobuf::Arena* arena, const UseItemReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kItemIdFieldNumber = 2,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string item_id = 2;
  void clear_item_id() ;
  const std::string& item_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* value);

  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(
      const std::string& value);
  std::string* _internal_mutable_item_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UseItemReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class UpdatePlayerTasksRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UpdatePlayerTasksRes) */ {
 public:
  inline UpdatePlayerTasksRes() : UpdatePlayerTasksRes(nullptr) {}
  ~UpdatePlayerTasksRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePlayerTasksRes(::google::protobuf::internal::ConstantInitialized);

  inline UpdatePlayerTasksRes(const UpdatePlayerTasksRes& from)
      : UpdatePlayerTasksRes(nullptr, from) {}
  UpdatePlayerTasksRes(UpdatePlayerTasksRes&& from) noexcept
    : UpdatePlayerTasksRes() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerTasksRes& operator=(const UpdatePlayerTasksRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerTasksRes& operator=(UpdatePlayerTasksRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerTasksRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerTasksRes* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerTasksRes*>(
               &_UpdatePlayerTasksRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdatePlayerTasksRes& a, UpdatePlayerTasksRes& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerTasksRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerTasksRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePlayerTasksRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePlayerTasksRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerTasksRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdatePlayerTasksRes& from) {
    UpdatePlayerTasksRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdatePlayerTasksRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UpdatePlayerTasksRes";
  }
  protected:
  explicit UpdatePlayerTasksRes(::google::protobuf::Arena* arena);
  UpdatePlayerTasksRes(::google::protobuf::Arena* arena, const UpdatePlayerTasksRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UpdatePlayerTasksRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class UpdatePlayerTasksReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UpdatePlayerTasksReq) */ {
 public:
  inline UpdatePlayerTasksReq() : UpdatePlayerTasksReq(nullptr) {}
  ~UpdatePlayerTasksReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePlayerTasksReq(::google::protobuf::internal::ConstantInitialized);

  inline UpdatePlayerTasksReq(const UpdatePlayerTasksReq& from)
      : UpdatePlayerTasksReq(nullptr, from) {}
  UpdatePlayerTasksReq(UpdatePlayerTasksReq&& from) noexcept
    : UpdatePlayerTasksReq() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerTasksReq& operator=(const UpdatePlayerTasksReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerTasksReq& operator=(UpdatePlayerTasksReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerTasksReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerTasksReq* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerTasksReq*>(
               &_UpdatePlayerTasksReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdatePlayerTasksReq& a, UpdatePlayerTasksReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerTasksReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerTasksReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePlayerTasksReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePlayerTasksReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerTasksReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdatePlayerTasksReq& from) {
    UpdatePlayerTasksReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdatePlayerTasksReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UpdatePlayerTasksReq";
  }
  protected:
  explicit UpdatePlayerTasksReq(::google::protobuf::Arena* arena);
  UpdatePlayerTasksReq(::google::protobuf::Arena* arena, const UpdatePlayerTasksReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated string tasks = 2;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  const std::string& tasks(int index) const;
  std::string* mutable_tasks(int index);
  void set_tasks(int index, const std::string& value);
  void set_tasks(int index, std::string&& value);
  void set_tasks(int index, const char* value);
  void set_tasks(int index, const char* value, std::size_t size);
  void set_tasks(int index, absl::string_view value);
  std::string* add_tasks();
  void add_tasks(const std::string& value);
  void add_tasks(std::string&& value);
  void add_tasks(const char* value);
  void add_tasks(const char* value, std::size_t size);
  void add_tasks(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tasks() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tasks();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UpdatePlayerTasksReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> tasks_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class UpdatePlayerCollectionRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UpdatePlayerCollectionRes) */ {
 public:
  inline UpdatePlayerCollectionRes() : UpdatePlayerCollectionRes(nullptr) {}
  ~UpdatePlayerCollectionRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePlayerCollectionRes(::google::protobuf::internal::ConstantInitialized);

  inline UpdatePlayerCollectionRes(const UpdatePlayerCollectionRes& from)
      : UpdatePlayerCollectionRes(nullptr, from) {}
  UpdatePlayerCollectionRes(UpdatePlayerCollectionRes&& from) noexcept
    : UpdatePlayerCollectionRes() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerCollectionRes& operator=(const UpdatePlayerCollectionRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerCollectionRes& operator=(UpdatePlayerCollectionRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerCollectionRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerCollectionRes* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerCollectionRes*>(
               &_UpdatePlayerCollectionRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdatePlayerCollectionRes& a, UpdatePlayerCollectionRes& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerCollectionRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerCollectionRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePlayerCollectionRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePlayerCollectionRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerCollectionRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdatePlayerCollectionRes& from) {
    UpdatePlayerCollectionRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdatePlayerCollectionRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UpdatePlayerCollectionRes";
  }
  protected:
  explicit UpdatePlayerCollectionRes(::google::protobuf::Arena* arena);
  UpdatePlayerCollectionRes(::google::protobuf::Arena* arena, const UpdatePlayerCollectionRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UpdatePlayerCollectionRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class UpdatePlayerCollectionReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UpdatePlayerCollectionReq) */ {
 public:
  inline UpdatePlayerCollectionReq() : UpdatePlayerCollectionReq(nullptr) {}
  ~UpdatePlayerCollectionReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePlayerCollectionReq(::google::protobuf::internal::ConstantInitialized);

  inline UpdatePlayerCollectionReq(const UpdatePlayerCollectionReq& from)
      : UpdatePlayerCollectionReq(nullptr, from) {}
  UpdatePlayerCollectionReq(UpdatePlayerCollectionReq&& from) noexcept
    : UpdatePlayerCollectionReq() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerCollectionReq& operator=(const UpdatePlayerCollectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerCollectionReq& operator=(UpdatePlayerCollectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerCollectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerCollectionReq* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerCollectionReq*>(
               &_UpdatePlayerCollectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UpdatePlayerCollectionReq& a, UpdatePlayerCollectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerCollectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerCollectionReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePlayerCollectionReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePlayerCollectionReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerCollectionReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdatePlayerCollectionReq& from) {
    UpdatePlayerCollectionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdatePlayerCollectionReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UpdatePlayerCollectionReq";
  }
  protected:
  explicit UpdatePlayerCollectionReq(::google::protobuf::Arena* arena);
  UpdatePlayerCollectionReq(::google::protobuf::Arena* arena, const UpdatePlayerCollectionReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated string collection = 2;
  int collection_size() const;
  private:
  int _internal_collection_size() const;

  public:
  void clear_collection() ;
  const std::string& collection(int index) const;
  std::string* mutable_collection(int index);
  void set_collection(int index, const std::string& value);
  void set_collection(int index, std::string&& value);
  void set_collection(int index, const char* value);
  void set_collection(int index, const char* value, std::size_t size);
  void set_collection(int index, absl::string_view value);
  std::string* add_collection();
  void add_collection(const std::string& value);
  void add_collection(std::string&& value);
  void add_collection(const char* value);
  void add_collection(const char* value, std::size_t size);
  void add_collection(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& collection() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_collection();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_collection() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_collection();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UpdatePlayerCollectionReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> collection_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class UpdatePlayerAchievementsRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UpdatePlayerAchievementsRes) */ {
 public:
  inline UpdatePlayerAchievementsRes() : UpdatePlayerAchievementsRes(nullptr) {}
  ~UpdatePlayerAchievementsRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePlayerAchievementsRes(::google::protobuf::internal::ConstantInitialized);

  inline UpdatePlayerAchievementsRes(const UpdatePlayerAchievementsRes& from)
      : UpdatePlayerAchievementsRes(nullptr, from) {}
  UpdatePlayerAchievementsRes(UpdatePlayerAchievementsRes&& from) noexcept
    : UpdatePlayerAchievementsRes() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerAchievementsRes& operator=(const UpdatePlayerAchievementsRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerAchievementsRes& operator=(UpdatePlayerAchievementsRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerAchievementsRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerAchievementsRes* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerAchievementsRes*>(
               &_UpdatePlayerAchievementsRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdatePlayerAchievementsRes& a, UpdatePlayerAchievementsRes& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerAchievementsRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerAchievementsRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePlayerAchievementsRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePlayerAchievementsRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerAchievementsRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdatePlayerAchievementsRes& from) {
    UpdatePlayerAchievementsRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdatePlayerAchievementsRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UpdatePlayerAchievementsRes";
  }
  protected:
  explicit UpdatePlayerAchievementsRes(::google::protobuf::Arena* arena);
  UpdatePlayerAchievementsRes(::google::protobuf::Arena* arena, const UpdatePlayerAchievementsRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UpdatePlayerAchievementsRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class UpdatePlayerAchievementsReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.UpdatePlayerAchievementsReq) */ {
 public:
  inline UpdatePlayerAchievementsReq() : UpdatePlayerAchievementsReq(nullptr) {}
  ~UpdatePlayerAchievementsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePlayerAchievementsReq(::google::protobuf::internal::ConstantInitialized);

  inline UpdatePlayerAchievementsReq(const UpdatePlayerAchievementsReq& from)
      : UpdatePlayerAchievementsReq(nullptr, from) {}
  UpdatePlayerAchievementsReq(UpdatePlayerAchievementsReq&& from) noexcept
    : UpdatePlayerAchievementsReq() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerAchievementsReq& operator=(const UpdatePlayerAchievementsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerAchievementsReq& operator=(UpdatePlayerAchievementsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerAchievementsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerAchievementsReq* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerAchievementsReq*>(
               &_UpdatePlayerAchievementsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdatePlayerAchievementsReq& a, UpdatePlayerAchievementsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerAchievementsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerAchievementsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePlayerAchievementsReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePlayerAchievementsReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerAchievementsReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdatePlayerAchievementsReq& from) {
    UpdatePlayerAchievementsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdatePlayerAchievementsReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.UpdatePlayerAchievementsReq";
  }
  protected:
  explicit UpdatePlayerAchievementsReq(::google::protobuf::Arena* arena);
  UpdatePlayerAchievementsReq(::google::protobuf::Arena* arena, const UpdatePlayerAchievementsReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAchievementsFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated string achievements = 2;
  int achievements_size() const;
  private:
  int _internal_achievements_size() const;

  public:
  void clear_achievements() ;
  const std::string& achievements(int index) const;
  std::string* mutable_achievements(int index);
  void set_achievements(int index, const std::string& value);
  void set_achievements(int index, std::string&& value);
  void set_achievements(int index, const char* value);
  void set_achievements(int index, const char* value, std::size_t size);
  void set_achievements(int index, absl::string_view value);
  std::string* add_achievements();
  void add_achievements(const std::string& value);
  void add_achievements(std::string&& value);
  void add_achievements(const char* value);
  void add_achievements(const char* value, std::size_t size);
  void add_achievements(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& achievements() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_achievements();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_achievements() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_achievements();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.UpdatePlayerAchievementsReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> achievements_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class SaveBattleResultRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.SaveBattleResultRes) */ {
 public:
  inline SaveBattleResultRes() : SaveBattleResultRes(nullptr) {}
  ~SaveBattleResultRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SaveBattleResultRes(::google::protobuf::internal::ConstantInitialized);

  inline SaveBattleResultRes(const SaveBattleResultRes& from)
      : SaveBattleResultRes(nullptr, from) {}
  SaveBattleResultRes(SaveBattleResultRes&& from) noexcept
    : SaveBattleResultRes() {
    *this = ::std::move(from);
  }

  inline SaveBattleResultRes& operator=(const SaveBattleResultRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveBattleResultRes& operator=(SaveBattleResultRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveBattleResultRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveBattleResultRes* internal_default_instance() {
    return reinterpret_cast<const SaveBattleResultRes*>(
               &_SaveBattleResultRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SaveBattleResultRes& a, SaveBattleResultRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveBattleResultRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveBattleResultRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveBattleResultRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveBattleResultRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SaveBattleResultRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SaveBattleResultRes& from) {
    SaveBattleResultRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SaveBattleResultRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.SaveBattleResultRes";
  }
  protected:
  explicit SaveBattleResultRes(::google::protobuf::Arena* arena);
  SaveBattleResultRes(::google::protobuf::Arena* arena, const SaveBattleResultRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.SaveBattleResultRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class SaveBattleResultReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.SaveBattleResultReq) */ {
 public:
  inline SaveBattleResultReq() : SaveBattleResultReq(nullptr) {}
  ~SaveBattleResultReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SaveBattleResultReq(::google::protobuf::internal::ConstantInitialized);

  inline SaveBattleResultReq(const SaveBattleResultReq& from)
      : SaveBattleResultReq(nullptr, from) {}
  SaveBattleResultReq(SaveBattleResultReq&& from) noexcept
    : SaveBattleResultReq() {
    *this = ::std::move(from);
  }

  inline SaveBattleResultReq& operator=(const SaveBattleResultReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveBattleResultReq& operator=(SaveBattleResultReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveBattleResultReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveBattleResultReq* internal_default_instance() {
    return reinterpret_cast<const SaveBattleResultReq*>(
               &_SaveBattleResultReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SaveBattleResultReq& a, SaveBattleResultReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveBattleResultReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveBattleResultReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveBattleResultReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveBattleResultReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SaveBattleResultReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SaveBattleResultReq& from) {
    SaveBattleResultReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SaveBattleResultReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.SaveBattleResultReq";
  }
  protected:
  explicit SaveBattleResultReq(::google::protobuf::Arena* arena);
  SaveBattleResultReq(::google::protobuf::Arena* arena, const SaveBattleResultReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kOpponentIdFieldNumber = 2,
    kBattleDataFieldNumber = 4,
    kIsVictoryFieldNumber = 3,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string opponent_id = 2;
  void clear_opponent_id() ;
  const std::string& opponent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_opponent_id(Arg_&& arg, Args_... args);
  std::string* mutable_opponent_id();
  PROTOBUF_NODISCARD std::string* release_opponent_id();
  void set_allocated_opponent_id(std::string* value);

  private:
  const std::string& _internal_opponent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opponent_id(
      const std::string& value);
  std::string* _internal_mutable_opponent_id();

  public:
  // string battle_data = 4;
  void clear_battle_data() ;
  const std::string& battle_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_battle_data(Arg_&& arg, Args_... args);
  std::string* mutable_battle_data();
  PROTOBUF_NODISCARD std::string* release_battle_data();
  void set_allocated_battle_data(std::string* value);

  private:
  const std::string& _internal_battle_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_battle_data(
      const std::string& value);
  std::string* _internal_mutable_battle_data();

  public:
  // bool is_victory = 3;
  void clear_is_victory() ;
  bool is_victory() const;
  void set_is_victory(bool value);

  private:
  bool _internal_is_victory() const;
  void _internal_set_is_victory(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.SaveBattleResultReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr opponent_id_;
    ::google::protobuf::internal::ArenaStringPtr battle_data_;
    bool is_victory_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class GetPlayerTasksRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.GetPlayerTasksRes) */ {
 public:
  inline GetPlayerTasksRes() : GetPlayerTasksRes(nullptr) {}
  ~GetPlayerTasksRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlayerTasksRes(::google::protobuf::internal::ConstantInitialized);

  inline GetPlayerTasksRes(const GetPlayerTasksRes& from)
      : GetPlayerTasksRes(nullptr, from) {}
  GetPlayerTasksRes(GetPlayerTasksRes&& from) noexcept
    : GetPlayerTasksRes() {
    *this = ::std::move(from);
  }

  inline GetPlayerTasksRes& operator=(const GetPlayerTasksRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlayerTasksRes& operator=(GetPlayerTasksRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlayerTasksRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlayerTasksRes* internal_default_instance() {
    return reinterpret_cast<const GetPlayerTasksRes*>(
               &_GetPlayerTasksRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetPlayerTasksRes& a, GetPlayerTasksRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlayerTasksRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlayerTasksRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlayerTasksRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlayerTasksRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlayerTasksRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlayerTasksRes& from) {
    GetPlayerTasksRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlayerTasksRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.GetPlayerTasksRes";
  }
  protected:
  explicit GetPlayerTasksRes(::google::protobuf::Arena* arena);
  GetPlayerTasksRes(::google::protobuf::Arena* arena, const GetPlayerTasksRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated string tasks = 2;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  const std::string& tasks(int index) const;
  std::string* mutable_tasks(int index);
  void set_tasks(int index, const std::string& value);
  void set_tasks(int index, std::string&& value);
  void set_tasks(int index, const char* value);
  void set_tasks(int index, const char* value, std::size_t size);
  void set_tasks(int index, absl::string_view value);
  std::string* add_tasks();
  void add_tasks(const std::string& value);
  void add_tasks(std::string&& value);
  void add_tasks(const char* value);
  void add_tasks(const char* value, std::size_t size);
  void add_tasks(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tasks() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tasks();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.GetPlayerTasksRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> tasks_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class GetPlayerTasksReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.GetPlayerTasksReq) */ {
 public:
  inline GetPlayerTasksReq() : GetPlayerTasksReq(nullptr) {}
  ~GetPlayerTasksReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlayerTasksReq(::google::protobuf::internal::ConstantInitialized);

  inline GetPlayerTasksReq(const GetPlayerTasksReq& from)
      : GetPlayerTasksReq(nullptr, from) {}
  GetPlayerTasksReq(GetPlayerTasksReq&& from) noexcept
    : GetPlayerTasksReq() {
    *this = ::std::move(from);
  }

  inline GetPlayerTasksReq& operator=(const GetPlayerTasksReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlayerTasksReq& operator=(GetPlayerTasksReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlayerTasksReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlayerTasksReq* internal_default_instance() {
    return reinterpret_cast<const GetPlayerTasksReq*>(
               &_GetPlayerTasksReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetPlayerTasksReq& a, GetPlayerTasksReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlayerTasksReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlayerTasksReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlayerTasksReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlayerTasksReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlayerTasksReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlayerTasksReq& from) {
    GetPlayerTasksReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlayerTasksReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.GetPlayerTasksReq";
  }
  protected:
  explicit GetPlayerTasksReq(::google::protobuf::Arena* arena);
  GetPlayerTasksReq(::google::protobuf::Arena* arena, const GetPlayerTasksReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.GetPlayerTasksReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class GetPlayerCollectionRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.GetPlayerCollectionRes) */ {
 public:
  inline GetPlayerCollectionRes() : GetPlayerCollectionRes(nullptr) {}
  ~GetPlayerCollectionRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlayerCollectionRes(::google::protobuf::internal::ConstantInitialized);

  inline GetPlayerCollectionRes(const GetPlayerCollectionRes& from)
      : GetPlayerCollectionRes(nullptr, from) {}
  GetPlayerCollectionRes(GetPlayerCollectionRes&& from) noexcept
    : GetPlayerCollectionRes() {
    *this = ::std::move(from);
  }

  inline GetPlayerCollectionRes& operator=(const GetPlayerCollectionRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlayerCollectionRes& operator=(GetPlayerCollectionRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlayerCollectionRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlayerCollectionRes* internal_default_instance() {
    return reinterpret_cast<const GetPlayerCollectionRes*>(
               &_GetPlayerCollectionRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetPlayerCollectionRes& a, GetPlayerCollectionRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlayerCollectionRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlayerCollectionRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlayerCollectionRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlayerCollectionRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlayerCollectionRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlayerCollectionRes& from) {
    GetPlayerCollectionRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlayerCollectionRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.GetPlayerCollectionRes";
  }
  protected:
  explicit GetPlayerCollectionRes(::google::protobuf::Arena* arena);
  GetPlayerCollectionRes(::google::protobuf::Arena* arena, const GetPlayerCollectionRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated string collection = 2;
  int collection_size() const;
  private:
  int _internal_collection_size() const;

  public:
  void clear_collection() ;
  const std::string& collection(int index) const;
  std::string* mutable_collection(int index);
  void set_collection(int index, const std::string& value);
  void set_collection(int index, std::string&& value);
  void set_collection(int index, const char* value);
  void set_collection(int index, const char* value, std::size_t size);
  void set_collection(int index, absl::string_view value);
  std::string* add_collection();
  void add_collection(const std::string& value);
  void add_collection(std::string&& value);
  void add_collection(const char* value);
  void add_collection(const char* value, std::size_t size);
  void add_collection(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& collection() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_collection();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_collection() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_collection();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.GetPlayerCollectionRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> collection_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class GetPlayerCollectionReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.GetPlayerCollectionReq) */ {
 public:
  inline GetPlayerCollectionReq() : GetPlayerCollectionReq(nullptr) {}
  ~GetPlayerCollectionReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlayerCollectionReq(::google::protobuf::internal::ConstantInitialized);

  inline GetPlayerCollectionReq(const GetPlayerCollectionReq& from)
      : GetPlayerCollectionReq(nullptr, from) {}
  GetPlayerCollectionReq(GetPlayerCollectionReq&& from) noexcept
    : GetPlayerCollectionReq() {
    *this = ::std::move(from);
  }

  inline GetPlayerCollectionReq& operator=(const GetPlayerCollectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlayerCollectionReq& operator=(GetPlayerCollectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlayerCollectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlayerCollectionReq* internal_default_instance() {
    return reinterpret_cast<const GetPlayerCollectionReq*>(
               &_GetPlayerCollectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetPlayerCollectionReq& a, GetPlayerCollectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlayerCollectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlayerCollectionReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlayerCollectionReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlayerCollectionReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlayerCollectionReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlayerCollectionReq& from) {
    GetPlayerCollectionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlayerCollectionReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.GetPlayerCollectionReq";
  }
  protected:
  explicit GetPlayerCollectionReq(::google::protobuf::Arena* arena);
  GetPlayerCollectionReq(::google::protobuf::Arena* arena, const GetPlayerCollectionReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.GetPlayerCollectionReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class GetPlayerAchievementsRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.GetPlayerAchievementsRes) */ {
 public:
  inline GetPlayerAchievementsRes() : GetPlayerAchievementsRes(nullptr) {}
  ~GetPlayerAchievementsRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlayerAchievementsRes(::google::protobuf::internal::ConstantInitialized);

  inline GetPlayerAchievementsRes(const GetPlayerAchievementsRes& from)
      : GetPlayerAchievementsRes(nullptr, from) {}
  GetPlayerAchievementsRes(GetPlayerAchievementsRes&& from) noexcept
    : GetPlayerAchievementsRes() {
    *this = ::std::move(from);
  }

  inline GetPlayerAchievementsRes& operator=(const GetPlayerAchievementsRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlayerAchievementsRes& operator=(GetPlayerAchievementsRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlayerAchievementsRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlayerAchievementsRes* internal_default_instance() {
    return reinterpret_cast<const GetPlayerAchievementsRes*>(
               &_GetPlayerAchievementsRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetPlayerAchievementsRes& a, GetPlayerAchievementsRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlayerAchievementsRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlayerAchievementsRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlayerAchievementsRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlayerAchievementsRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlayerAchievementsRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlayerAchievementsRes& from) {
    GetPlayerAchievementsRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlayerAchievementsRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.GetPlayerAchievementsRes";
  }
  protected:
  explicit GetPlayerAchievementsRes(::google::protobuf::Arena* arena);
  GetPlayerAchievementsRes(::google::protobuf::Arena* arena, const GetPlayerAchievementsRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAchievementsFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated string achievements = 2;
  int achievements_size() const;
  private:
  int _internal_achievements_size() const;

  public:
  void clear_achievements() ;
  const std::string& achievements(int index) const;
  std::string* mutable_achievements(int index);
  void set_achievements(int index, const std::string& value);
  void set_achievements(int index, std::string&& value);
  void set_achievements(int index, const char* value);
  void set_achievements(int index, const char* value, std::size_t size);
  void set_achievements(int index, absl::string_view value);
  std::string* add_achievements();
  void add_achievements(const std::string& value);
  void add_achievements(std::string&& value);
  void add_achievements(const char* value);
  void add_achievements(const char* value, std::size_t size);
  void add_achievements(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& achievements() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_achievements();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_achievements() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_achievements();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.GetPlayerAchievementsRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> achievements_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class GetPlayerAchievementsReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.GetPlayerAchievementsReq) */ {
 public:
  inline GetPlayerAchievementsReq() : GetPlayerAchievementsReq(nullptr) {}
  ~GetPlayerAchievementsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlayerAchievementsReq(::google::protobuf::internal::ConstantInitialized);

  inline GetPlayerAchievementsReq(const GetPlayerAchievementsReq& from)
      : GetPlayerAchievementsReq(nullptr, from) {}
  GetPlayerAchievementsReq(GetPlayerAchievementsReq&& from) noexcept
    : GetPlayerAchievementsReq() {
    *this = ::std::move(from);
  }

  inline GetPlayerAchievementsReq& operator=(const GetPlayerAchievementsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlayerAchievementsReq& operator=(GetPlayerAchievementsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlayerAchievementsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlayerAchievementsReq* internal_default_instance() {
    return reinterpret_cast<const GetPlayerAchievementsReq*>(
               &_GetPlayerAchievementsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetPlayerAchievementsReq& a, GetPlayerAchievementsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlayerAchievementsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlayerAchievementsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlayerAchievementsReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlayerAchievementsReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlayerAchievementsReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlayerAchievementsReq& from) {
    GetPlayerAchievementsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlayerAchievementsReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.GetPlayerAchievementsReq";
  }
  protected:
  explicit GetPlayerAchievementsReq(::google::protobuf::Arena* arena);
  GetPlayerAchievementsReq(::google::protobuf::Arena* arena, const GetPlayerAchievementsReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.GetPlayerAchievementsReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class AddItemRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.AddItemRes) */ {
 public:
  inline AddItemRes() : AddItemRes(nullptr) {}
  ~AddItemRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddItemRes(::google::protobuf::internal::ConstantInitialized);

  inline AddItemRes(const AddItemRes& from)
      : AddItemRes(nullptr, from) {}
  AddItemRes(AddItemRes&& from) noexcept
    : AddItemRes() {
    *this = ::std::move(from);
  }

  inline AddItemRes& operator=(const AddItemRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddItemRes& operator=(AddItemRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddItemRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddItemRes* internal_default_instance() {
    return reinterpret_cast<const AddItemRes*>(
               &_AddItemRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AddItemRes& a, AddItemRes& b) {
    a.Swap(&b);
  }
  inline void Swap(AddItemRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddItemRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddItemRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddItemRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddItemRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddItemRes& from) {
    AddItemRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddItemRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.AddItemRes";
  }
  protected:
  explicit AddItemRes(::google::protobuf::Arena* arena);
  AddItemRes(::google::protobuf::Arena* arena, const AddItemRes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.AddItemRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};// -------------------------------------------------------------------

class AddItemReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc_server.AddItemReq) */ {
 public:
  inline AddItemReq() : AddItemReq(nullptr) {}
  ~AddItemReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddItemReq(::google::protobuf::internal::ConstantInitialized);

  inline AddItemReq(const AddItemReq& from)
      : AddItemReq(nullptr, from) {}
  AddItemReq(AddItemReq&& from) noexcept
    : AddItemReq() {
    *this = ::std::move(from);
  }

  inline AddItemReq& operator=(const AddItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddItemReq& operator=(AddItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddItemReq* internal_default_instance() {
    return reinterpret_cast<const AddItemReq*>(
               &_AddItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AddItemReq& a, AddItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AddItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddItemReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddItemReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddItemReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddItemReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddItemReq& from) {
    AddItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddItemReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rpc_server.AddItemReq";
  }
  protected:
  explicit AddItemReq(::google::protobuf::Arena* arena);
  AddItemReq(::google::protobuf::Arena* arena, const AddItemReq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kItemIdFieldNumber = 2,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string item_id = 2;
  void clear_item_id() ;
  const std::string& item_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* value);

  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(
      const std::string& value);
  std::string* _internal_mutable_item_id();

  public:
  // @@protoc_insertion_point(class_scope:rpc_server.AddItemReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_5flogic_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetPlayerCollectionReq

// string player_id = 1;
inline void GetPlayerCollectionReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GetPlayerCollectionReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerCollectionReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlayerCollectionReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerCollectionReq.player_id)
}
inline std::string* GetPlayerCollectionReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerCollectionReq.player_id)
  return _s;
}
inline const std::string& GetPlayerCollectionReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void GetPlayerCollectionReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* GetPlayerCollectionReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* GetPlayerCollectionReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.GetPlayerCollectionReq.player_id)
  return _impl_.player_id_.Release();
}
inline void GetPlayerCollectionReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.GetPlayerCollectionReq.player_id)
}

// -------------------------------------------------------------------

// GetPlayerCollectionRes

// string player_id = 1;
inline void GetPlayerCollectionRes::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GetPlayerCollectionRes::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerCollectionRes.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlayerCollectionRes::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerCollectionRes.player_id)
}
inline std::string* GetPlayerCollectionRes::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerCollectionRes.player_id)
  return _s;
}
inline const std::string& GetPlayerCollectionRes::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void GetPlayerCollectionRes::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* GetPlayerCollectionRes::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* GetPlayerCollectionRes::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.GetPlayerCollectionRes.player_id)
  return _impl_.player_id_.Release();
}
inline void GetPlayerCollectionRes::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.GetPlayerCollectionRes.player_id)
}

// repeated string collection = 2;
inline int GetPlayerCollectionRes::_internal_collection_size() const {
  return _internal_collection().size();
}
inline int GetPlayerCollectionRes::collection_size() const {
  return _internal_collection_size();
}
inline void GetPlayerCollectionRes::clear_collection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.collection_.Clear();
}
inline std::string* GetPlayerCollectionRes::add_collection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_collection()->Add();
  // @@protoc_insertion_point(field_add_mutable:rpc_server.GetPlayerCollectionRes.collection)
  return _s;
}
inline const std::string& GetPlayerCollectionRes::collection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerCollectionRes.collection)
  return _internal_collection().Get(index);
}
inline std::string* GetPlayerCollectionRes::mutable_collection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerCollectionRes.collection)
  return _internal_mutable_collection()->Mutable(index);
}
inline void GetPlayerCollectionRes::set_collection(int index, const std::string& value) {
  _internal_mutable_collection()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::set_collection(int index, std::string&& value) {
  _internal_mutable_collection()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::set_collection(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_collection()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::set_collection(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_collection()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::set_collection(int index, absl::string_view value) {
  _internal_mutable_collection()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::add_collection(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::add_collection(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::add_collection(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::add_collection(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc_server.GetPlayerCollectionRes.collection)
}
inline void GetPlayerCollectionRes::add_collection(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:rpc_server.GetPlayerCollectionRes.collection)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetPlayerCollectionRes::collection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rpc_server.GetPlayerCollectionRes.collection)
  return _internal_collection();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetPlayerCollectionRes::mutable_collection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rpc_server.GetPlayerCollectionRes.collection)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_collection();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetPlayerCollectionRes::_internal_collection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collection_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetPlayerCollectionRes::_internal_mutable_collection() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.collection_;
}

// -------------------------------------------------------------------

// UpdatePlayerCollectionReq

// string player_id = 1;
inline void UpdatePlayerCollectionReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& UpdatePlayerCollectionReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerCollectionReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdatePlayerCollectionReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerCollectionReq.player_id)
}
inline std::string* UpdatePlayerCollectionReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerCollectionReq.player_id)
  return _s;
}
inline const std::string& UpdatePlayerCollectionReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void UpdatePlayerCollectionReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* UpdatePlayerCollectionReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* UpdatePlayerCollectionReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UpdatePlayerCollectionReq.player_id)
  return _impl_.player_id_.Release();
}
inline void UpdatePlayerCollectionReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UpdatePlayerCollectionReq.player_id)
}

// repeated string collection = 2;
inline int UpdatePlayerCollectionReq::_internal_collection_size() const {
  return _internal_collection().size();
}
inline int UpdatePlayerCollectionReq::collection_size() const {
  return _internal_collection_size();
}
inline void UpdatePlayerCollectionReq::clear_collection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.collection_.Clear();
}
inline std::string* UpdatePlayerCollectionReq::add_collection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_collection()->Add();
  // @@protoc_insertion_point(field_add_mutable:rpc_server.UpdatePlayerCollectionReq.collection)
  return _s;
}
inline const std::string& UpdatePlayerCollectionReq::collection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerCollectionReq.collection)
  return _internal_collection().Get(index);
}
inline std::string* UpdatePlayerCollectionReq::mutable_collection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerCollectionReq.collection)
  return _internal_mutable_collection()->Mutable(index);
}
inline void UpdatePlayerCollectionReq::set_collection(int index, const std::string& value) {
  _internal_mutable_collection()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::set_collection(int index, std::string&& value) {
  _internal_mutable_collection()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::set_collection(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_collection()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::set_collection(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_collection()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::set_collection(int index, absl::string_view value) {
  _internal_mutable_collection()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::add_collection(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::add_collection(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::add_collection(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::add_collection(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline void UpdatePlayerCollectionReq::add_collection(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collection()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:rpc_server.UpdatePlayerCollectionReq.collection)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdatePlayerCollectionReq::collection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rpc_server.UpdatePlayerCollectionReq.collection)
  return _internal_collection();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdatePlayerCollectionReq::mutable_collection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rpc_server.UpdatePlayerCollectionReq.collection)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_collection();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdatePlayerCollectionReq::_internal_collection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collection_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdatePlayerCollectionReq::_internal_mutable_collection() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.collection_;
}

// -------------------------------------------------------------------

// UpdatePlayerCollectionRes

// bool success = 1;
inline void UpdatePlayerCollectionRes::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool UpdatePlayerCollectionRes::success() const {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerCollectionRes.success)
  return _internal_success();
}
inline void UpdatePlayerCollectionRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerCollectionRes.success)
}
inline bool UpdatePlayerCollectionRes::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void UpdatePlayerCollectionRes::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void UpdatePlayerCollectionRes::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdatePlayerCollectionRes::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerCollectionRes.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdatePlayerCollectionRes::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerCollectionRes.message)
}
inline std::string* UpdatePlayerCollectionRes::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerCollectionRes.message)
  return _s;
}
inline const std::string& UpdatePlayerCollectionRes::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void UpdatePlayerCollectionRes::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UpdatePlayerCollectionRes::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UpdatePlayerCollectionRes::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UpdatePlayerCollectionRes.message)
  return _impl_.message_.Release();
}
inline void UpdatePlayerCollectionRes::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UpdatePlayerCollectionRes.message)
}

// -------------------------------------------------------------------

// GetPlayerAchievementsReq

// string player_id = 1;
inline void GetPlayerAchievementsReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GetPlayerAchievementsReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerAchievementsReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlayerAchievementsReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerAchievementsReq.player_id)
}
inline std::string* GetPlayerAchievementsReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerAchievementsReq.player_id)
  return _s;
}
inline const std::string& GetPlayerAchievementsReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void GetPlayerAchievementsReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* GetPlayerAchievementsReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* GetPlayerAchievementsReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.GetPlayerAchievementsReq.player_id)
  return _impl_.player_id_.Release();
}
inline void GetPlayerAchievementsReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.GetPlayerAchievementsReq.player_id)
}

// -------------------------------------------------------------------

// GetPlayerAchievementsRes

// string player_id = 1;
inline void GetPlayerAchievementsRes::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GetPlayerAchievementsRes::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerAchievementsRes.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlayerAchievementsRes::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerAchievementsRes.player_id)
}
inline std::string* GetPlayerAchievementsRes::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerAchievementsRes.player_id)
  return _s;
}
inline const std::string& GetPlayerAchievementsRes::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void GetPlayerAchievementsRes::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* GetPlayerAchievementsRes::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* GetPlayerAchievementsRes::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.GetPlayerAchievementsRes.player_id)
  return _impl_.player_id_.Release();
}
inline void GetPlayerAchievementsRes::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.GetPlayerAchievementsRes.player_id)
}

// repeated string achievements = 2;
inline int GetPlayerAchievementsRes::_internal_achievements_size() const {
  return _internal_achievements().size();
}
inline int GetPlayerAchievementsRes::achievements_size() const {
  return _internal_achievements_size();
}
inline void GetPlayerAchievementsRes::clear_achievements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achievements_.Clear();
}
inline std::string* GetPlayerAchievementsRes::add_achievements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_achievements()->Add();
  // @@protoc_insertion_point(field_add_mutable:rpc_server.GetPlayerAchievementsRes.achievements)
  return _s;
}
inline const std::string& GetPlayerAchievementsRes::achievements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerAchievementsRes.achievements)
  return _internal_achievements().Get(index);
}
inline std::string* GetPlayerAchievementsRes::mutable_achievements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerAchievementsRes.achievements)
  return _internal_mutable_achievements()->Mutable(index);
}
inline void GetPlayerAchievementsRes::set_achievements(int index, const std::string& value) {
  _internal_mutable_achievements()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::set_achievements(int index, std::string&& value) {
  _internal_mutable_achievements()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::set_achievements(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_achievements()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::set_achievements(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_achievements()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::set_achievements(int index, absl::string_view value) {
  _internal_mutable_achievements()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::add_achievements(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::add_achievements(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::add_achievements(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::add_achievements(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline void GetPlayerAchievementsRes::add_achievements(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:rpc_server.GetPlayerAchievementsRes.achievements)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetPlayerAchievementsRes::achievements() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rpc_server.GetPlayerAchievementsRes.achievements)
  return _internal_achievements();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetPlayerAchievementsRes::mutable_achievements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rpc_server.GetPlayerAchievementsRes.achievements)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_achievements();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetPlayerAchievementsRes::_internal_achievements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.achievements_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetPlayerAchievementsRes::_internal_mutable_achievements() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.achievements_;
}

// -------------------------------------------------------------------

// UpdatePlayerAchievementsReq

// string player_id = 1;
inline void UpdatePlayerAchievementsReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& UpdatePlayerAchievementsReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerAchievementsReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdatePlayerAchievementsReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerAchievementsReq.player_id)
}
inline std::string* UpdatePlayerAchievementsReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerAchievementsReq.player_id)
  return _s;
}
inline const std::string& UpdatePlayerAchievementsReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void UpdatePlayerAchievementsReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* UpdatePlayerAchievementsReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* UpdatePlayerAchievementsReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UpdatePlayerAchievementsReq.player_id)
  return _impl_.player_id_.Release();
}
inline void UpdatePlayerAchievementsReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UpdatePlayerAchievementsReq.player_id)
}

// repeated string achievements = 2;
inline int UpdatePlayerAchievementsReq::_internal_achievements_size() const {
  return _internal_achievements().size();
}
inline int UpdatePlayerAchievementsReq::achievements_size() const {
  return _internal_achievements_size();
}
inline void UpdatePlayerAchievementsReq::clear_achievements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achievements_.Clear();
}
inline std::string* UpdatePlayerAchievementsReq::add_achievements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_achievements()->Add();
  // @@protoc_insertion_point(field_add_mutable:rpc_server.UpdatePlayerAchievementsReq.achievements)
  return _s;
}
inline const std::string& UpdatePlayerAchievementsReq::achievements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerAchievementsReq.achievements)
  return _internal_achievements().Get(index);
}
inline std::string* UpdatePlayerAchievementsReq::mutable_achievements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerAchievementsReq.achievements)
  return _internal_mutable_achievements()->Mutable(index);
}
inline void UpdatePlayerAchievementsReq::set_achievements(int index, const std::string& value) {
  _internal_mutable_achievements()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::set_achievements(int index, std::string&& value) {
  _internal_mutable_achievements()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::set_achievements(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_achievements()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::set_achievements(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_achievements()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::set_achievements(int index, absl::string_view value) {
  _internal_mutable_achievements()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::add_achievements(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::add_achievements(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::add_achievements(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::add_achievements(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline void UpdatePlayerAchievementsReq::add_achievements(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_achievements()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:rpc_server.UpdatePlayerAchievementsReq.achievements)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdatePlayerAchievementsReq::achievements() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rpc_server.UpdatePlayerAchievementsReq.achievements)
  return _internal_achievements();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdatePlayerAchievementsReq::mutable_achievements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rpc_server.UpdatePlayerAchievementsReq.achievements)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_achievements();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdatePlayerAchievementsReq::_internal_achievements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.achievements_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdatePlayerAchievementsReq::_internal_mutable_achievements() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.achievements_;
}

// -------------------------------------------------------------------

// UpdatePlayerAchievementsRes

// bool success = 1;
inline void UpdatePlayerAchievementsRes::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool UpdatePlayerAchievementsRes::success() const {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerAchievementsRes.success)
  return _internal_success();
}
inline void UpdatePlayerAchievementsRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerAchievementsRes.success)
}
inline bool UpdatePlayerAchievementsRes::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void UpdatePlayerAchievementsRes::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void UpdatePlayerAchievementsRes::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdatePlayerAchievementsRes::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerAchievementsRes.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdatePlayerAchievementsRes::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerAchievementsRes.message)
}
inline std::string* UpdatePlayerAchievementsRes::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerAchievementsRes.message)
  return _s;
}
inline const std::string& UpdatePlayerAchievementsRes::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void UpdatePlayerAchievementsRes::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UpdatePlayerAchievementsRes::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UpdatePlayerAchievementsRes::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UpdatePlayerAchievementsRes.message)
  return _impl_.message_.Release();
}
inline void UpdatePlayerAchievementsRes::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UpdatePlayerAchievementsRes.message)
}

// -------------------------------------------------------------------

// GetPlayerTasksReq

// string player_id = 1;
inline void GetPlayerTasksReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GetPlayerTasksReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerTasksReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlayerTasksReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerTasksReq.player_id)
}
inline std::string* GetPlayerTasksReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerTasksReq.player_id)
  return _s;
}
inline const std::string& GetPlayerTasksReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void GetPlayerTasksReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* GetPlayerTasksReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* GetPlayerTasksReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.GetPlayerTasksReq.player_id)
  return _impl_.player_id_.Release();
}
inline void GetPlayerTasksReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.GetPlayerTasksReq.player_id)
}

// -------------------------------------------------------------------

// GetPlayerTasksRes

// string player_id = 1;
inline void GetPlayerTasksRes::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GetPlayerTasksRes::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerTasksRes.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlayerTasksRes::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerTasksRes.player_id)
}
inline std::string* GetPlayerTasksRes::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerTasksRes.player_id)
  return _s;
}
inline const std::string& GetPlayerTasksRes::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void GetPlayerTasksRes::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* GetPlayerTasksRes::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* GetPlayerTasksRes::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.GetPlayerTasksRes.player_id)
  return _impl_.player_id_.Release();
}
inline void GetPlayerTasksRes::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.GetPlayerTasksRes.player_id)
}

// repeated string tasks = 2;
inline int GetPlayerTasksRes::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int GetPlayerTasksRes::tasks_size() const {
  return _internal_tasks_size();
}
inline void GetPlayerTasksRes::clear_tasks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasks_.Clear();
}
inline std::string* GetPlayerTasksRes::add_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add_mutable:rpc_server.GetPlayerTasksRes.tasks)
  return _s;
}
inline const std::string& GetPlayerTasksRes::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.GetPlayerTasksRes.tasks)
  return _internal_tasks().Get(index);
}
inline std::string* GetPlayerTasksRes::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rpc_server.GetPlayerTasksRes.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline void GetPlayerTasksRes::set_tasks(int index, const std::string& value) {
  _internal_mutable_tasks()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::set_tasks(int index, std::string&& value) {
  _internal_mutable_tasks()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::set_tasks(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tasks()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::set_tasks(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tasks()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::set_tasks(int index, absl::string_view value) {
  _internal_mutable_tasks()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::add_tasks(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::add_tasks(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::add_tasks(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::add_tasks(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc_server.GetPlayerTasksRes.tasks)
}
inline void GetPlayerTasksRes::add_tasks(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:rpc_server.GetPlayerTasksRes.tasks)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetPlayerTasksRes::tasks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rpc_server.GetPlayerTasksRes.tasks)
  return _internal_tasks();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetPlayerTasksRes::mutable_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rpc_server.GetPlayerTasksRes.tasks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetPlayerTasksRes::_internal_tasks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetPlayerTasksRes::_internal_mutable_tasks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasks_;
}

// -------------------------------------------------------------------

// UpdatePlayerTasksReq

// string player_id = 1;
inline void UpdatePlayerTasksReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& UpdatePlayerTasksReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerTasksReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdatePlayerTasksReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerTasksReq.player_id)
}
inline std::string* UpdatePlayerTasksReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerTasksReq.player_id)
  return _s;
}
inline const std::string& UpdatePlayerTasksReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void UpdatePlayerTasksReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* UpdatePlayerTasksReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* UpdatePlayerTasksReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UpdatePlayerTasksReq.player_id)
  return _impl_.player_id_.Release();
}
inline void UpdatePlayerTasksReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UpdatePlayerTasksReq.player_id)
}

// repeated string tasks = 2;
inline int UpdatePlayerTasksReq::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int UpdatePlayerTasksReq::tasks_size() const {
  return _internal_tasks_size();
}
inline void UpdatePlayerTasksReq::clear_tasks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasks_.Clear();
}
inline std::string* UpdatePlayerTasksReq::add_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add_mutable:rpc_server.UpdatePlayerTasksReq.tasks)
  return _s;
}
inline const std::string& UpdatePlayerTasksReq::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerTasksReq.tasks)
  return _internal_tasks().Get(index);
}
inline std::string* UpdatePlayerTasksReq::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerTasksReq.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline void UpdatePlayerTasksReq::set_tasks(int index, const std::string& value) {
  _internal_mutable_tasks()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::set_tasks(int index, std::string&& value) {
  _internal_mutable_tasks()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::set_tasks(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tasks()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::set_tasks(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tasks()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::set_tasks(int index, absl::string_view value) {
  _internal_mutable_tasks()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::add_tasks(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::add_tasks(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::add_tasks(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::add_tasks(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline void UpdatePlayerTasksReq::add_tasks(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tasks()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:rpc_server.UpdatePlayerTasksReq.tasks)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdatePlayerTasksReq::tasks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rpc_server.UpdatePlayerTasksReq.tasks)
  return _internal_tasks();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdatePlayerTasksReq::mutable_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rpc_server.UpdatePlayerTasksReq.tasks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdatePlayerTasksReq::_internal_tasks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdatePlayerTasksReq::_internal_mutable_tasks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasks_;
}

// -------------------------------------------------------------------

// UpdatePlayerTasksRes

// bool success = 1;
inline void UpdatePlayerTasksRes::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool UpdatePlayerTasksRes::success() const {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerTasksRes.success)
  return _internal_success();
}
inline void UpdatePlayerTasksRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerTasksRes.success)
}
inline bool UpdatePlayerTasksRes::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void UpdatePlayerTasksRes::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void UpdatePlayerTasksRes::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdatePlayerTasksRes::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UpdatePlayerTasksRes.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdatePlayerTasksRes::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UpdatePlayerTasksRes.message)
}
inline std::string* UpdatePlayerTasksRes::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rpc_server.UpdatePlayerTasksRes.message)
  return _s;
}
inline const std::string& UpdatePlayerTasksRes::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void UpdatePlayerTasksRes::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UpdatePlayerTasksRes::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UpdatePlayerTasksRes::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UpdatePlayerTasksRes.message)
  return _impl_.message_.Release();
}
inline void UpdatePlayerTasksRes::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UpdatePlayerTasksRes.message)
}

// -------------------------------------------------------------------

// AddItemReq

// string player_id = 1;
inline void AddItemReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& AddItemReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.AddItemReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddItemReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.AddItemReq.player_id)
}
inline std::string* AddItemReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.AddItemReq.player_id)
  return _s;
}
inline const std::string& AddItemReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void AddItemReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* AddItemReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* AddItemReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.AddItemReq.player_id)
  return _impl_.player_id_.Release();
}
inline void AddItemReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.AddItemReq.player_id)
}

// string item_id = 2;
inline void AddItemReq::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& AddItemReq::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.AddItemReq.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddItemReq::set_item_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.AddItemReq.item_id)
}
inline std::string* AddItemReq::mutable_item_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.AddItemReq.item_id)
  return _s;
}
inline const std::string& AddItemReq::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_.Get();
}
inline void AddItemReq::_internal_set_item_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(value, GetArena());
}
inline std::string* AddItemReq::_internal_mutable_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_id_.Mutable( GetArena());
}
inline std::string* AddItemReq::release_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.AddItemReq.item_id)
  return _impl_.item_id_.Release();
}
inline void AddItemReq::set_allocated_item_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_id_.IsDefault()) {
          _impl_.item_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.AddItemReq.item_id)
}

// -------------------------------------------------------------------

// AddItemRes

// bool success = 1;
inline void AddItemRes::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool AddItemRes::success() const {
  // @@protoc_insertion_point(field_get:rpc_server.AddItemRes.success)
  return _internal_success();
}
inline void AddItemRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rpc_server.AddItemRes.success)
}
inline bool AddItemRes::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void AddItemRes::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void AddItemRes::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AddItemRes::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.AddItemRes.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddItemRes::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.AddItemRes.message)
}
inline std::string* AddItemRes::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rpc_server.AddItemRes.message)
  return _s;
}
inline const std::string& AddItemRes::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void AddItemRes::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* AddItemRes::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* AddItemRes::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.AddItemRes.message)
  return _impl_.message_.Release();
}
inline void AddItemRes::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.AddItemRes.message)
}

// -------------------------------------------------------------------

// UseItemReq

// string player_id = 1;
inline void UseItemReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& UseItemReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UseItemReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UseItemReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UseItemReq.player_id)
}
inline std::string* UseItemReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.UseItemReq.player_id)
  return _s;
}
inline const std::string& UseItemReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void UseItemReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* UseItemReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* UseItemReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UseItemReq.player_id)
  return _impl_.player_id_.Release();
}
inline void UseItemReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UseItemReq.player_id)
}

// string item_id = 2;
inline void UseItemReq::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& UseItemReq::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UseItemReq.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UseItemReq::set_item_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UseItemReq.item_id)
}
inline std::string* UseItemReq::mutable_item_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.UseItemReq.item_id)
  return _s;
}
inline const std::string& UseItemReq::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_.Get();
}
inline void UseItemReq::_internal_set_item_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(value, GetArena());
}
inline std::string* UseItemReq::_internal_mutable_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_id_.Mutable( GetArena());
}
inline std::string* UseItemReq::release_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UseItemReq.item_id)
  return _impl_.item_id_.Release();
}
inline void UseItemReq::set_allocated_item_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_id_.IsDefault()) {
          _impl_.item_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UseItemReq.item_id)
}

// -------------------------------------------------------------------

// UseItemRes

// bool success = 1;
inline void UseItemRes::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool UseItemRes::success() const {
  // @@protoc_insertion_point(field_get:rpc_server.UseItemRes.success)
  return _internal_success();
}
inline void UseItemRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rpc_server.UseItemRes.success)
}
inline bool UseItemRes::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void UseItemRes::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void UseItemRes::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UseItemRes::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.UseItemRes.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UseItemRes::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.UseItemRes.message)
}
inline std::string* UseItemRes::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rpc_server.UseItemRes.message)
  return _s;
}
inline const std::string& UseItemRes::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void UseItemRes::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UseItemRes::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UseItemRes::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.UseItemRes.message)
  return _impl_.message_.Release();
}
inline void UseItemRes::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.UseItemRes.message)
}

// -------------------------------------------------------------------

// SaveBattleResultReq

// string player_id = 1;
inline void SaveBattleResultReq::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& SaveBattleResultReq::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.SaveBattleResultReq.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaveBattleResultReq::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.SaveBattleResultReq.player_id)
}
inline std::string* SaveBattleResultReq::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.SaveBattleResultReq.player_id)
  return _s;
}
inline const std::string& SaveBattleResultReq::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void SaveBattleResultReq::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* SaveBattleResultReq::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* SaveBattleResultReq::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.SaveBattleResultReq.player_id)
  return _impl_.player_id_.Release();
}
inline void SaveBattleResultReq::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.SaveBattleResultReq.player_id)
}

// string opponent_id = 2;
inline void SaveBattleResultReq::clear_opponent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.opponent_id_.ClearToEmpty();
}
inline const std::string& SaveBattleResultReq::opponent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.SaveBattleResultReq.opponent_id)
  return _internal_opponent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaveBattleResultReq::set_opponent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.opponent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.SaveBattleResultReq.opponent_id)
}
inline std::string* SaveBattleResultReq::mutable_opponent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_opponent_id();
  // @@protoc_insertion_point(field_mutable:rpc_server.SaveBattleResultReq.opponent_id)
  return _s;
}
inline const std::string& SaveBattleResultReq::_internal_opponent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.opponent_id_.Get();
}
inline void SaveBattleResultReq::_internal_set_opponent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.opponent_id_.Set(value, GetArena());
}
inline std::string* SaveBattleResultReq::_internal_mutable_opponent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.opponent_id_.Mutable( GetArena());
}
inline std::string* SaveBattleResultReq::release_opponent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.SaveBattleResultReq.opponent_id)
  return _impl_.opponent_id_.Release();
}
inline void SaveBattleResultReq::set_allocated_opponent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.opponent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.opponent_id_.IsDefault()) {
          _impl_.opponent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.SaveBattleResultReq.opponent_id)
}

// bool is_victory = 3;
inline void SaveBattleResultReq::clear_is_victory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_victory_ = false;
}
inline bool SaveBattleResultReq::is_victory() const {
  // @@protoc_insertion_point(field_get:rpc_server.SaveBattleResultReq.is_victory)
  return _internal_is_victory();
}
inline void SaveBattleResultReq::set_is_victory(bool value) {
  _internal_set_is_victory(value);
  // @@protoc_insertion_point(field_set:rpc_server.SaveBattleResultReq.is_victory)
}
inline bool SaveBattleResultReq::_internal_is_victory() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_victory_;
}
inline void SaveBattleResultReq::_internal_set_is_victory(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_victory_ = value;
}

// string battle_data = 4;
inline void SaveBattleResultReq::clear_battle_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battle_data_.ClearToEmpty();
}
inline const std::string& SaveBattleResultReq::battle_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.SaveBattleResultReq.battle_data)
  return _internal_battle_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaveBattleResultReq::set_battle_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.battle_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.SaveBattleResultReq.battle_data)
}
inline std::string* SaveBattleResultReq::mutable_battle_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_battle_data();
  // @@protoc_insertion_point(field_mutable:rpc_server.SaveBattleResultReq.battle_data)
  return _s;
}
inline const std::string& SaveBattleResultReq::_internal_battle_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battle_data_.Get();
}
inline void SaveBattleResultReq::_internal_set_battle_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.battle_data_.Set(value, GetArena());
}
inline std::string* SaveBattleResultReq::_internal_mutable_battle_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.battle_data_.Mutable( GetArena());
}
inline std::string* SaveBattleResultReq::release_battle_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.SaveBattleResultReq.battle_data)
  return _impl_.battle_data_.Release();
}
inline void SaveBattleResultReq::set_allocated_battle_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battle_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.battle_data_.IsDefault()) {
          _impl_.battle_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.SaveBattleResultReq.battle_data)
}

// -------------------------------------------------------------------

// SaveBattleResultRes

// bool success = 1;
inline void SaveBattleResultRes::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool SaveBattleResultRes::success() const {
  // @@protoc_insertion_point(field_get:rpc_server.SaveBattleResultRes.success)
  return _internal_success();
}
inline void SaveBattleResultRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rpc_server.SaveBattleResultRes.success)
}
inline bool SaveBattleResultRes::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void SaveBattleResultRes::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void SaveBattleResultRes::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SaveBattleResultRes::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rpc_server.SaveBattleResultRes.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaveBattleResultRes::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rpc_server.SaveBattleResultRes.message)
}
inline std::string* SaveBattleResultRes::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rpc_server.SaveBattleResultRes.message)
  return _s;
}
inline const std::string& SaveBattleResultRes::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void SaveBattleResultRes::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* SaveBattleResultRes::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* SaveBattleResultRes::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rpc_server.SaveBattleResultRes.message)
  return _impl_.message_.Release();
}
inline void SaveBattleResultRes::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_server.SaveBattleResultRes.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace rpc_server


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_server_5flogic_2eproto_2epb_2eh
