# Poor Server STL 项目优化路线图

> **文档版本**: v1.1.0  
> **创建日期**: 2024年  
> **最后更新**: 2024年  
> **适用项目阶段**: 架构设计完成，进入实现优化阶段

---

## 📋 目录

- [项目现状评估](#项目现状评估)
- [核心问题分析](#核心问题分析)
- [技术债务追踪](#技术债务追踪)
- [优化路线图](#优化路线图)
- [详细实施计划](#详细实施计划)
- [时间规划](#时间规划)
- [参考资料](#参考资料)

---

## 🎯 文档目的

本文档旨在：

1. **评估项目当前状态** - 识别已完成的工作和存在的问题
2. **规划优化方向** - 提供清晰的改进路线图
3. **指导开发工作** - 为后续开发提供可执行的计划
4. **追踪进度** - 便于检查优化工作的完成情况

---

## 🚀 快速开始指南

### 如果你只有 10 分钟

**推荐阅读**：
1. 📊 [核心问题分析](#核心问题分析) - 了解当前最大的问题
2. 🎯 [立即行动](#立即行动) - 查看第一步该做什么

**核心结论**：
- 🔴 **最大问题**：2000+ 行重复代码（影响所有后续开发）
- ✅ **解决方案**：阶段 1 代码重构（2-3 周）
- 🚀 **立即开始**：实现 BaseServer 基类

---

### 如果你只有 1 小时

**推荐阅读顺序**：
1. 📊 [项目现状评估](#项目现状评估) - 10 分钟
2. ⚠️ [核心问题分析](#核心问题分析) - 20 分钟
3. 📋 [阶段 1：代码重构](#阶段-1代码重构2-3-周) - 30 分钟

**你将了解**：
- ✅ 项目有哪些优势（文档、架构、工具链）
- 🔴 存在哪些问题（代码重复、Skynet 缺失）
- 🛠️ 如何立即开始（BaseServer 设计）

**行动建议**：
- 开始实现 `BaseServer` 基类
- 重构第一个服务器（Central Server）作为示范

---

### 如果你有 1 天时间

**推荐阅读顺序**：
1. 📊 [项目现状评估](#项目现状评估) - 30 分钟
2. ⚠️ [核心问题分析](#核心问题分析) - 1 小时
3. 📋 [阶段 1-2 详细规划](#阶段-1代码重构2-3-周) - 2 小时
4. 📅 [时间规划](#总体时间规划) - 30 分钟
5. 🛠️ [开发建议](#开发建议) - 1 小时

**你将获得**：
- ✅ 完整的问题理解
- ✅ 清晰的解决方案
- ✅ 可执行的行动计划
- ✅ 时间和风险评估

**行动建议**：
- 制定你的个人开发计划
- 开始执行阶段 1 的第一个任务
- 设置开发环境和工具

---

### 完整阅读路径（推荐）

**适合场景**：完整理解项目并制定长期计划

```
第 1 步：了解背景（30 分钟）
└── 项目现状评估

第 2 步：明确问题（1 小时）
└── 核心问题分析 + 问题优先级排序

第 3 步：掌握方案（3-4 小时）
├── 阶段 1：代码重构
├── 阶段 2：Skynet 集成
└── 阶段 3-5：按需查阅

第 4 步：规划执行（1 小时）
├── 时间规划
├── 风险控制
└── 检查清单

第 5 步：参考资料（随时查阅）
├── Skynet 学习资源
├── 开发建议
└── 故障排查
```

**预期收获**：
- ✅ 深入理解项目现状和问题
- ✅ 掌握完整的优化路线图
- ✅ 获得可执行的实施计划
- ✅ 了解潜在风险和应对措施

---

## 🚧 紧急事宜

请优先处理以下紧急事宜，以确保项目顺利进行：

1. **解决 2000+ 行代码重复问题**：这阻碍了所有后续开发，必须立即重构
2. **尽快集成 Skynet**：包含游戏逻辑的核心功能依赖于 Skynet，需优先实现集成
3. **建立测试体系**：保证代码质量，降低未来维护成本，需尽快搭建单元测试和集成测试框架

请将以上事项作为优先级最高的工作项，尽快制定详细计划并执行。

---

## 📅 时间规划

### 短期目标（1-2 个月）

**优先级：最高 ⚡**

```
Week 1-3: 阶段 1 - 代码重构
├── Week 1: 基类设计与实现
├── Week 2: ThreadManager 和连接池统一
└── Week 3: ConfigManager 和测试

Week 4-7: 阶段 2 - Skynet 集成
├── Week 4: 通信方案设计和 SkynetBridge
├── Week 5: Lua 端桥接实现
├── Week 6: Protobuf 集成
└── Week 7: 示例服务和测试

总计：7 周（约 2 个月）
```

**里程碑**：
- ✅ 代码重复问题解决
- ✅ C++ 与 Skynet 通信建立
- ✅ 基础架构完全搭建完成

---

### 中期目标（3-6 个月）

**优先级：高 🔥**

```
Week 8-10: 阶段 3 - 架构优化
├── Week 8: 事件系统和错误处理
├── Week 9: 性能监控系统
└── Week 10: 日志增强和测试框架

Week 11-16: 阶段 4 - 功能实现（并行）
├── Week 11-14: 炉石传说核心玩法
│   ├── Week 11: 卡牌管理和套牌系统
│   ├── Week 12: 战斗逻辑基础
│   ├── Week 13: 战斗逻辑完善
│   └── Week 14: 成就和收藏系统
│
└── Week 15-16: 网盘高级功能
    ├── Week 15: 断点续传和文件秒传
    └── Week 16: 图片压缩和文件分享

总计：9 周（约 2.5 个月）
```

**里程碑**：
- ✅ 系统可观测性完善
- ✅ 核心游戏功能实现
- ✅ 网盘功能基本完整

---

### 长期目标（6-12 个月）

**优先级：中 📊**

```
Week 17-18: 阶段 5 - 部署运维
├── Week 17: Docker 和 CI/CD
└── Week 18: 运维文档和监控

Week 19+: 持续优化
├── 性能测试和调优
├── 功能扩展
├── Bug 修复
└── 文档完善

总计：持续进行
```

**里程碑**：
- ✅ 生产环境可用
- ✅ 自动化部署流程
- ✅ 持续迭代能力

---

## 🎯 推荐的工作顺序

### 第一阶段：立即开始（Week 1-3）

**Week 1: 基类重构**

```
Day 1-2: 设计与实现
├── 完善 base_server.h
├── 实现 base_server.cpp
└── 单元测试

Day 3-4: 示范迁移
├── 重构 central_server
├── 验证功能正常
└── 性能对比

Day 5-7: 全面迁移
├── 重构其他 7 个服务器
├── 删除重复代码
└── 集成测试
```

**Week 2: 工具类统一**

```
Day 1-2: ThreadManager 改进
├── 修复编译警告
├── 增加新功能
└── 所有服务器迁移

Day 3-4: 通用连接池
├── 设计模板接口
├── 实现基本功能
└── 迁移现有连接池

Day 5: 测试验证
├── 单元测试
├── 性能测试
└── 稳定性测试
```

**Week 3: 配置管理**

```
Day 1-2: ConfigManager 实现
├── 设计接口
├── 实现功能
└── 单元测试

Day 3-4: 迁移配置读取
├── 所有 main.cpp 使用 ConfigManager
├── 删除重复代码
└── 验证功能

Day 5: 总结与优化
├── 代码审查
├── 文档更新
└── 准备下阶段
```

---

### 第二阶段：紧接进行（Week 4-7）

**Week 4: 通信基础**

```
Day 1-2: 方案设计
├── 确定通信协议
├── 设计消息格式
└── 编写设计文档

Day 3-5: SkynetBridge 实现
├── 连接管理
├── 消息发送/接收
├── 协议实现
└── 单元测试
```

**Week 5-6: Lua 端集成**

```
Day 1-3: cpp_bridge.lua
├── 协议解析
├── Protobuf 支持
└── 辅助函数

Day 4-7: cpp_gateway.lua
├── TCP 监听
├── 消息处理
├── 服务路由
└── 错误处理

Day 8-10: 测试
├── Echo 服务测试
├── 压力测试
└── 稳定性测试
```

**Week 7: 示例与文档**

```
Day 1-3: 示例服务
├── player_manager 实现
├── battle_service 框架
└── 功能测试

Day 4-5: 文档编写
├── 使用文档
├── API 文档
└── 最佳实践
```

---

## 📉 技术债务追踪

### 高优先级技术债务清单

| 编号 | 技术债务 | 影响范围 | 预估工作量 | 优先级 | 状态 | 负责阶段 |
|------|---------|---------|-----------|--------|------|---------|
| TD-001 | 代码重复（2000+行） | 全部 8 个服务器 | 2-3 周 | P0 🔴 | 待处理 | 阶段 1 |
| TD-002 | Skynet 集成缺失 | 架构完整性 | 3-4 周 | P1 🟡 | 待处理 | 阶段 2 |
| TD-003 | ThreadManager 未使用 | 代码质量 | 1-2 天 | P2 🟡 | 待处理 | 阶段 1 |
| TD-004 | 连接池不统一 | 可扩展性 | 2-3 天 | P3 🟡 | 待处理 | 阶段 1 |
| TD-005 | 配置管理分散 | 易用性 | 1-2 天 | P4 🟢 | 待处理 | 阶段 1 |
| TD-006 | EventManager 未使用 | 代码质量 | 2-3 天 | P2 🟡 | 待处理 | 阶段 3 |
| TD-007 | 缺少错误处理体系 | 系统稳定性 | 3-4 天 | P2 🟡 | 待处理 | 阶段 3 |
| TD-008 | 缺少性能监控 | 可观测性 | 4-5 天 | P2 🟡 | 待处理 | 阶段 3 |

---

### 技术债务总览

**债务统计**：

```
总技术债务估算：8-12 周
已偿还：0 周 (0%)
剩余：8-12 周 (100%)

按优先级分布：
├── P0（紧急）: 1 项 - 2-3 周
├── P1（高）  : 1 项 - 3-4 周
├── P2（中）  : 3 项 - 7-10 天
├── P3（低）  : 1 项 - 2-3 天
└── P4（可选）: 1 项 - 1-2 天
```

**危险区域**（重复代码最多）：

```
高风险文件：
├── src/central/server/central_server_impl.cpp   (~300 行，50% 重复)
├── src/gateway/server/gateway_server_impl.cpp   (~350 行，55% 重复)
├── src/login/server/login_server_impl.cpp       (~280 行，45% 重复)
├── src/db/server/db_server_impl.cpp             (~320 行，50% 重复)
├── src/file/server/file_server_impl.cpp         (~290 行，48% 重复)
└── 所有 main.cpp                                (~30 行/个，100% 重复)

重复代码热点：
1. 线程池管理函数    - 800 行
2. 服务注册函数      - 400 行
3. 心跳发送函数      - 200 行
4. 连接池初始化      - 300 行
5. 配置文件读取      - 300 行
```

**优化潜力**：

```
代码量优化：
├── 当前总代码量：~15,000 行
├── 重复代码：~2,000 行 (13%)
├── 优化后预期：~10,000 行
└── 减少比例：33%

开发效率提升：
├── 新增服务器：从 2 天 → 0.5 天 (减少 75%)
├── Bug 修复：从改 8 处 → 改 1 处 (减少 87.5%)
└── 代码审查：从 2 小时 → 1 小时 (减少 50%)
```

---

### 债务偿还计划

**短期计划（Week 1-7）**：清除核心技术债务

```
阶段 1（Week 1-3）：偿还 TD-001, TD-003, TD-004, TD-005
├── Week 1: BaseServer 基类（偿还 TD-001 部分）
├── Week 2: ThreadManager 统一（偿还 TD-003, TD-004）
└── Week 3: ConfigManager（偿还 TD-005）

债务偿还：~2000 行重复代码 → ~200 行
技术债务减少：40% ✅
```

```
阶段 2（Week 4-7）：偿还 TD-002
├── Week 4-5: SkynetBridge 实现
├── Week 6: Protobuf 集成
└── Week 7: 示例服务

债务偿还：架构完整性 0% → 90%
技术债务减少：80% ✅
```

**中期计划（Week 8-10）**：偿还剩余债务

```
阶段 3（Week 8-10）：偿还 TD-006, TD-007, TD-008
├── Week 8: EventManager + 错误处理（偿还 TD-006, TD-007）
└── Week 9-10: 性能监控（偿还 TD-008)

债务偿还：基础设施完善
技术债务减少：100% ✅
```

---

### 债务监控指标

**关键指标**：

| 指标 | 当前值 | 目标值 | 阶段 1 后 | 阶段 2 后 | 阶段 3 后 |
|------|--------|--------|-----------|-----------|-----------|
| 重复代码行数 | ~2000 | <200 | ~200 ✅ | ~200 | ~200 |
| 重复代码率 | 13% | <2% | 2% ✅ | 2% | 2% |
| 未使用工具类 | 3 个 | 0 个 | 0 个 ✅ | 0 个 | 0 个 |
| 架构完整性 | 60% | 95% | 65% | 90% ✅ | 95% |
| 代码覆盖率 | 0% | >60% | 20% | 40% | 60% ✅ |

**跟踪方式**：
- 📊 每周更新债务状态
- 📈 生成债务趋势图
- ✅ 标记已完成项
- ⚠️ 及时识别新债务

---

## 🗺️ 优化路线图


````````
**Lua/Skynet 社区**:
```
├── Lua 官网: https://www.lua.org/
├── Skynet 讨论组: Google Groups
└── GitHub Issues
```

---

## 🛠️ 工具和资源清单

### 开发工具推荐

**IDE / 代码编辑器**：

```
主力 IDE（选一个）：
├── Visual Studio 2022（Windows，推荐）⭐⭐⭐⭐⭐
│   ├── 优点：调试功能强大，C++ 支持最好
│   ├── 缺点：只支持 Windows
│   └── 适合：Windows 开发者
│
├── CLion（跨平台）⭐⭐⭐⭐⭐
│   ├── 优点：CMake 集成好，跨平台
│   ├── 缺点：付费（学生免费）
│   └── 适合：需要跨平台开发
│
└── VS Code + 插件（轻量级）⭐⭐⭐⭐
    ├── 优点：轻量、免费、插件丰富
    ├── 缺点：调试体验不如专业 IDE
    └── 适合：喜欢轻量工具的开发者
```

**推荐的 VS Code 插件**：
```
必装：
├── C/C++ (Microsoft)              - C++ 语言支持
├── C/C++ Extension Pack           - C++ 工具包
├── CMake Tools                    - CMake 集成
├── GitLens                        - Git 增强
└── GitHub Copilot                 - AI 代码助手

推荐：
├── Protobuf Support               - Protobuf 语法高亮
├── Lua                            - Lua 语言支持
├── Docker                         - Docker 集成
├── Remote - SSH                   - 远程开发
└── Better Comments                - 注释增强
```

---

### 调试工具

**C++ 调试**：
```
调试器：
├── GDB（Linux）⭐⭐⭐⭐⭐
│   ├── 基本用法：gdb ./server
│   ├── 断点：break main
│   ├── 运行：run
│   ├── 查看变量：print var
│   └── 调用栈：backtrace
│
├── LLDB（macOS/Linux）⭐⭐⭐⭐
│   ├── 类似 GDB，命令稍有不同
│   └── macOS 上的主力调试器
│
└── Visual Studio Debugger（Windows）⭐⭐⭐⭐⭐
    ├── 图形化界面
    ├── 断点、监视、调用栈
    └── 最友好的调试体验
```

**性能分析**：
```
内存分析：
├── Valgrind（Linux）⭐⭐⭐⭐⭐
│   ├── 内存泄漏检测
│   ├── valgrind --leak-check=full ./server
│   └── 输出详细的泄漏报告
│
├── Heaptrack（Linux）⭐⭐⭐⭐
│   ├── 图形化内存分析
│   └── heaptrack ./server
│
└── Visual Studio Profiler（Windows）⭐⭐⭐⭐⭐
    ├── 内存、CPU 分析
    └── 图形化报告

性能分析：
├── gprof（Linux）⭐⭐⭐
│   ├── 函数调用次数和时间
│   ├── 编译时加 -pg 选项
│   └── gprof ./server gmon.out
│
├── perf（Linux）⭐⭐⭐⭐⭐
│   ├── Linux 系统级性能工具
│   ├── perf record ./server
│   └── perf report
│
└── Google Benchmark⭐⭐⭐⭐
    ├── 微基准测试框架
    └── 适合测试单个函数性能
```

**网络调试**：
```
抓包分析：
├── Wireshark（图形化）⭐⭐⭐⭐⭐
│   ├── 强大的网络协议分析
│   ├── 支持 gRPC / HTTP/2
│   └── 适合分析复杂协议
│
└── tcpdump（命令行）⭐⭐⭐⭐
    ├── 轻量级抓包工具
    ├── tcpdump -i any port 8888
    └── 适合快速诊断

API 测试：
├── Postman（HTTP/gRPC）⭐⭐⭐⭐⭐
│   ├── 图形化 API 测试
│   ├── 支持 gRPC（需要插件）
│   └── 请求历史记录
│
├── grpcurl（gRPC 专用）⭐⭐⭐⭐
│   ├── 命令行 gRPC 客户端
│   ├── grpcurl -plaintext localhost:50051 list
│   └── 类似 curl 的使用方式
│
└── curl（HTTP）⭐⭐⭐⭐⭐
    ├── 通用 HTTP 客户端
    └── 简单快速
```

---

### 文档工具

**代码文档生成**：
```
├── Doxygen⭐⭐⭐⭐⭐
│   ├── C++ 文档生成标准工具
│   ├── 支持多种输出格式（HTML, LaTeX, PDF）
│   ├── 配置：Doxyfile
│   └── 使用：doxygen Doxyfile
│
├── Sphinx + Breathe⭐⭐⭐⭐
│   ├── Python 文档工具 + C++ 支持
│   └── 适合混合项目
│
└── Markdown⭐⭐⭐⭐⭐
    ├── 项目当前使用
    ├── 简单易用
    └── GitHub 原生支持
```

**图表工具**：
```
├── Graphviz⭐⭐⭐⭐
│   ├── 代码生成架构图
│   ├── 文本描述 → 图形
│   └── Doxygen 可集成
│
├── PlantUML⭐⭐⭐⭐⭐
│   ├── UML 图（时序图、类图等）
│   ├── 文本描述 → UML
│   └── VS Code 插件支持
│
└── draw.io⭐⭐⭐⭐⭐
    ├── 在线图表工具
    ├── 免费、强大
    └── 适合流程图、架构图
```

---

### 第三方库清单

**当前已使用**：

```
核心依赖：
├── gRPC v1.50+                    - RPC 框架
├── Protobuf v3.21+                - 数据序列化
├── spdlog v1.11+                  - 日志库
├── MySQL Connector C++ v8.0+      - MySQL 客户端
├── cpp_redis v4.0+                - Redis 客户端
└── Lua 5.4                        - Skynet 依赖

版本要求：
├── C++ 标准：C++20（或 C++17）
├── CMake：3.15+
└── 编译器：GCC 10+ / Clang 10+ / MSVC 2019+
```

**推荐新增**（按需）：

```
测试框架：
├── Google Test (gtest)⭐⭐⭐⭐⭐
│   ├── 单元测试框架
│   ├── 功能强大，广泛使用
│   └── 配合 Google Mock 使用
│
├── Google Mock (gmock)⭐⭐⭐⭐
│   ├── Mock 框架
│   └── 测试依赖注入
│
└── Google Benchmark⭐⭐⭐⭐
    ├── 性能基准测试
    └── 微基准测试

工具库：
├── nlohmann/json⭐⭐⭐⭐⭐
│   ├── 现代 C++ JSON 库
│   ├── 头文件单文件
│   └── 易用性极佳
│
├── fmt⭐⭐⭐⭐⭐
│   ├── 格式化库（C++20 std::format 的基础）
│   ├── spdlog 已依赖
│   └── 字符串格式化
│
├── Boost.Asio⭐⭐⭐⭐
│   ├── 异步 IO 库
│   ├── 如果需要更复杂的网络功能
│   └── 学习曲线较陡
│
└── Abseil (Google)⭐⭐⭐⭐
    ├── Google 的 C++ 基础库
    ├── 字符串、容器、同步工具
    └── 现代 C++ 最佳实践

Lua 相关：
├── lua-protobuf⭐⭐⭐⭐⭐
│   ├── Lua 的 Protobuf 库
│   ├── Skynet 集成必需
│   └── 云风维护
│
└── LuaBridge⭐⭐⭐⭐
    ├── C++ 和 Lua 绑定库
    ├── 简化 C++/Lua 交互
    └── 可选，LuaManager 已提供基础功能
```

---

### 在线工具

**Protobuf 相关**：
```
├── Protobuf Decoder⭐⭐⭐⭐
│   ├── 在线解码 Protobuf 消息
│   ├── https://protobuf-decoder.netlify.app/
│   └── 调试 Protobuf 数据
│
├── Protobuf Online Editor⭐⭐⭐
│   ├── 在线编辑 .proto 文件
│   ├── https://protogen.marcgravell.com/
│   └── 生成代码预览
│
└── Buf⭐⭐⭐⭐
    ├── Protobuf 工具链
    ├── https://buf.build/
    └── Lint, Breaking Change 检测
```

**C++ 相关**：
```
├── Compiler Explorer (godbolt.org)⭐⭐⭐⭐⭐
│   ├── 在线编译器，查看汇编
│   ├── https://godbolt.org/
│   └── 支持多种编译器和标准
│
├── C++ Insights⭐⭐⭐⭐⭐
│   ├── 查看编译器如何转换代码
│   ├── https://cppinsights.io/
│   └── 理解模板展开、Lambda 等
│
├── Quick Bench⭐⭐⭐⭐
│   ├── 在线 C++ 基准测试
│   ├── https://quick-bench.com/
│   └── 快速对比性能
│
└── C++ Shell⭐⭐⭐
    ├── 在线 C++ 编译运行
    ├── https://cpp.sh/
    └── 快速测试代码片段
```

**其他工具**：
```
├── JSON Editor Online⭐⭐⭐⭐
│   ├── https://jsoneditoronline.org/
│   └── JSON 格式化、验证
│
├── Regex101⭐⭐⭐⭐⭐
│   ├── https://regex101.com/
│   └── 正则表达式测试
│
├── Crontab Guru⭐⭐⭐⭐
│   ├── https://crontab.guru/
│   └── Cron 表达式验证
│
└── Epoch Converter⭐⭐⭐⭐
    ├── https://www.epochconverter.com/
    └── Unix 时间戳转换
```

---

### 持续集成 / 部署工具

**CI/CD 平台**：
```
├── GitHub Actions⭐⭐⭐⭐⭐
│   ├── 与 GitHub 深度集成
│   ├── 免费额度充足（公开仓库无限）
│   └── 推荐用于本项目
│
├── GitLab CI⭐⭐⭐⭐
│   ├── 功能完善
│   └── 如果使用 GitLab
│
└── Jenkins⭐⭐⭐
    ├── 老牌 CI/CD 工具
    ├── 功能强大但配置复杂
    └── 适合企业环境
```

**容器化**：
```
├── Docker⭐⭐⭐⭐⭐
│   ├── 容器化标准
│   ├── 项目已配置
│   └── 必备工具
│
├── Docker Compose⭐⭐⭐⭐⭐
│   ├── 多容器编排
│   ├── 项目已配置
│   └── 开发环境首选
│
└── Kubernetes (K8s)⭐⭐⭐⭐
    ├── 生产环境容器编排
    ├── 学习曲线陡峭
    └── 大规模部署时使用
```

**监控工具**：
```
├── Prometheus⭐⭐⭐⭐⭐
│   ├── 开源监控系统
│   ├── 时序数据库
│   └── 与 Grafana 配合
│
├── Grafana⭐⭐⭐⭐⭐
│   ├── 可视化面板
│   ├── 支持多种数据源
│   └── 实时监控图表
│
└── ELK Stack⭐⭐⭐⭐
    ├── Elasticsearch + Logstash + Kibana
    ├── 日志聚合分析
    └── 适合大规模日志
```

---

### 学习资源

**C++ 学习**：
```
在线资源：
├── CppReference⭐⭐⭐⭐⭐
│   ├── https://en.cppreference.com/
│   └── C++ 标准库参考（首选）
│
├── LearnCpp⭐⭐⭐⭐⭐
│   ├── https://www.learncpp.com/
│   └── 系统的 C++ 教程
│
├── ISO C++ 官网⭐⭐⭐⭐
│   ├── https://isocpp.org/
│   └── 官方资源、指南
│
└── Awesome C++⭐⭐⭐⭐
    ├── https://github.com/fffaraz/awesome-cpp
    └── C++ 库和资源汇总

书籍：
├── 《C++ Primer》（第5版）⭐⭐⭐⭐⭐
├── 《Effective Modern C++》⭐⭐⭐⭐⭐
├── 《C++ Concurrency in Action》⭐⭐⭐⭐
└── 《设计模式》（GoF）⭐⭐⭐⭐⭐
```

**Skynet / Lua 学习**：
```
官方资源：
├── Skynet GitHub⭐⭐⭐⭐⭐
│   ├── https://github.com/cloudwu/skynet
│   └── 官方源码和 Wiki
│
├── Lua 官网⭐⭐⭐⭐⭐
│   ├── https://www.lua.org/
│   └── 官方文档和手册
│
└── 云风博客⭐⭐⭐⭐⭐
    ├── https://blog.codingnow.com/
    └── Skynet 作者博客

项目文档（本项目）：
├── skynet_quickstart.md⭐⭐⭐⭐⭐
├── skynet_concepts.md⭐⭐⭐⭐⭐
└── skynet_api_reference.md⭐⭐⭐⭐⭐
```

**系统设计**：
```
├── 《游戏服务器架构》⭐⭐⭐⭐
├── 《高性能 MySQL》⭐⭐⭐⭐⭐
├── 《Redis 设计与实现》⭐⭐⭐⭐
└── 《分布式系统原理与范型》⭐⭐⭐⭐
```

---

## ❓ 常见问题 FAQ

### 开发相关

**Q1: 为什么要花 2-3 周做代码重构？直接开发新功能不行吗？**

A: **不建议跳过重构，原因如下**：

```
现状问题：
├── 2000+ 行重复代码严重拖慢所有后续开发
├── 每次修改需要同步改 8 处，容易遗漏
├── 新功能开发会继续引入重复代码
└── 技术债务雪球会越滚越大

投入产出：
├── 投入：2-3 周重构时间
├── 产出：后续数月的高效开发
├── 回报：每个新服务器开发时间减少 75%
└── 结论：非常值得！

风险分析：
├── 跳过重构：短期快，长期慢（债务累积）
└── 先重构：短期慢，长期快（一劳永逸）
```

**建议**：先完成阶段 1 重构，再开发新功能。

---

**Q2: Skynet 学习曲线陡峭，可以不用吗？**

A: **不建议放弃 Skynet，原因如下**：

```
为什么不能放弃：
├── Skynet 是项目的核心特色和技术优势
├── 游戏逻辑需要热更新能力（Skynet + Lua）
├── 高并发处理（Actor 模型）
└── 放弃 Skynet = 放弃架构优势

学习成本：
├── 初步掌握：1-2 周（跟随文档学习）
├── 熟练使用：1 个月（边做边学）
└── 精通：3-6 个月（持续实践）

长期收益：
├── 热更新：无需停服即可修复 Bug 和发布新功能
├── 灵活性：Lua 脚本易于调整游戏逻辑
├── 高并发：单服支持 10,000+ 玩家
└── 降低维护成本
```

**建议**：
1. 先完成阶段 1 重构（不涉及 Skynet）
2. 阶段 2 集中 3-4 周学习并集成 Skynet
3. 使用项目提供的 Skynet 文档（已准备好）

---

**Q3: 能不能跳过某些阶段？比如直接做功能开发？**

A: **可以调整顺序，但不建议跳过阶段 1-2**：

```
必须做（不可跳过）：
├── ✅ 阶段 1（代码重构）
│   └── 原因：是所有后续工作的基础，不做会越来越难
│
└── ✅ 阶段 2（Skynet 集成）
    └── 原因：架构完整性依赖它，游戏逻辑要在这里实现

可以延后：
├── ⚠️ 阶段 3（架构优化）
│   └── 影响：系统稳定性和可观测性下降
│
├── ⚠️ 阶段 4（功能开发）
│   └── 影响：功能交付延后
│
└── ⚠️ 阶段 5（部署运维）
    └── 影响：生产环境部署延后

调整建议：
├── 如果急需某个功能：阶段 1 → 阶段 2 → 功能开发 → 阶段 3 → 阶段 5
└── 如果追求稳定：严格按照阶段 1-5 顺序执行
```

---

**Q4: 时间估算是否准确？会不会严重超期？**

A: **时间估算已包含 30% 缓冲，相对可控**：

```
估算依据：
├── 基于类似项目经验
├── 考虑学习曲线
├── 包含测试和修复时间
└── 预留 30% 缓冲时间

可能超期的情况：
├── 团队经验不足（增加 20-30%）
├── 遇到技术难题（增加 10-20%）
├── 需求频繁变更（增加 30-50%）
└── 人员变动（影响较大）

降低超期风险：
├── ✅ 严格执行阶段 1-2（这两个阶段时间相对可控）
├── ✅ 每周做进度回顾，及时调整
├── ✅ 使用 GitHub Projects 或 Jira 跟踪任务
└── ✅ 遇到困难及时寻求帮助
```

**建议使用的进度跟踪工具**：
- GitHub Projects（看板管理）
- 本文档的检查清单
- 每周周报（见文档末尾模板）

---

**Q5: 一个人开发，是否可行？**

A: **可行，但需要合理安排时间**：

```
时间估算（单人）：
├── 阶段 1-2（核心）：7-10 周（全职）
├── 阶段 3（优化）  ：2-3 周
├── 阶段 4（功能）  ：4-6 周（核心功能）
└── 总计：13-19 周（3-5 个月）

如果是兼职开发：
├── 每周投入 20 小时 → 时间 × 2
├── 每周投入 10 小时 → 时间 × 4
└── 每周投入 5 小时  → 时间 × 8

建议的优先级：
1. ✅ 阶段 1（必须）- 消除重复代码
2. ✅ 阶段 2（必须）- Skynet 集成
3. ⚠️ 阶段 3（推荐）- 架构优化
4. ⚠️ 阶段 4（按需）- 功能开发（分批实现）
5. ⚠️ 阶段 5（延后）- 部署运维（初期可本地运行）
```

**单人开发建议**：
- 优先完成阶段 1-2，确保基础牢固
- 功能开发分批进行，每次只做一个模块
- 使用项目已有的丰富文档
- 善用 AI 助手（GitHub Copilot、ChatGPT）

---

### 技术相关

**Q6: C++20 特性是否必须？可以用 C++17 吗？**

A: **可以降级到 C++17，但不推荐**：

```
当前使用的 C++20 特性：
├── std::invoke_result（替代 std::result_of）
├── Concepts（使用较少）
└── 其他现代特性（少量）

降级到 C++17 的工作量：
├── 修改 ThreadManager 的类型萃取
├── 移除 Concepts 约束
├── 预估工作量：2-3 小时
└── 兼容性：95% 以上代码可兼容

建议：
├── ✅ 如果编译器支持 C++20：使用 C++20
├── ⚠️ 如果只支持 C++17：可以降级（少量修改）
└── ❌ 不建议使用 C++14 或更早版本
```

**编译器要求**：
- C++20: GCC 10+, Clang 10+, MSVC 2019+
- C++17: GCC 7+, Clang 5+, MSVC 2017+

---

**Q7: gRPC 性能是否足够？有更好的选择吗？**

A: **gRPC 性能完全够用，是推荐选择**：

```
gRPC 性能指标：
├── 单机 QPS：100,000+ （HTTP/2）
├── 延迟：<10ms (P99)
├── 支持流式传输
└── 跨语言支持好

性能对比：
├── gRPC (HTTP/2)     ：★★★★★ （推荐）
├── REST (HTTP/1.1)   ：★★★☆☆
├── Thrift            ：★★★★☆
├── Cap'n Proto       ：★★★★★ （更复杂）
└── FlatBuffers       ：★★★★★ （游戏常用）

何时考虑替代：
├── 需要极致性能（<1ms 延迟）→ Cap'n Proto / FlatBuffers
├── 需要零拷贝 → Cap'n Proto
├── 游戏客户端 → FlatBuffers（更适合）
└── 当前项目：gRPC 足够 ✅
```

**建议**：
- 先用 gRPC，性能不够再优化
- 重点优化业务逻辑，而不是通信协议
- 可以在客户端和服务器间使用其他协议

---

**Q8: Redis 和 MySQL 都需要吗？**

A: **建议都保留，两者定位不同**：

```
MySQL：
├── 用途：持久化存储、复杂查询、事务
├── 适用场景：
│   ├── 用户账号数据
│   ├── 玩家数据（需要持久化的）
│   ├── 游戏配置表
│   └── 历史记录

Redis：
├── 用途：缓存、会话管理、实时数据
├── 适用场景：
│   ├── 登录会话（token）
│   ├── 在线状态
│   ├── 排行榜
│   ├── 消息队列
│   └── 分布式锁

协作模式：
├── 写入：先写 MySQL（持久化）
├── 读取：先读 Redis（缓存），未命中再读 MySQL
└── 缓存：定期同步 MySQL 数据到 Redis
```

**简化方案（资源紧张）**：
- 初期可以只用 MySQL（去掉 Redis）
- 后期性能不够时再引入 Redis
- 影响：初期性能略低，但功能完整

---

### 部署相关

**Q9: Docker 部署是否必须？**

A: **不是必须，但强烈推荐**：

```
Docker 的优势：
├── ✅ 环境一致性（开发、测试、生产完全一致）
├── ✅ 快速部署（一键启动所有服务）
├── ✅ 易于扩展（横向扩展简单）
├── ✅ 隔离性好（各服务互不影响）
└── ✅ 回滚方便（版本管理）

Docker 的劣势：
├── ⚠️ 学习成本（需要了解 Docker 基础）
├── ⚠️ 资源开销（略高于直接运行，但可忽略）
└── ⚠️ 调试略复杂（需要进入容器）

不用 Docker 的方案：
├── 开发阶段：直接本地编译运行（更方便调试）
├── 测试阶段：可以用 Docker（环境一致）
└── 生产阶段：强烈建议用 Docker（部署运维方便）
```

**建议**：
- 开发时：本地运行（方便调试）
- 测试和生产：Docker 部署
- 项目已有完善的 Docker 配置，可以直接使用

---

**Q10: 如何进行压力测试？**

A: **分阶段、多维度测试**：

```
测试层次（按顺序）：

1. 单元测试（Google Test）
   ├── 测试对象：单个函数/类
   ├── 工具：gtest
   ├── 目标：功能正确性
   └── 覆盖率：>60%

2. 集成测试（自定义脚本）
   ├── 测试对象：服务器间通信
   ├── 工具：自定义测试客户端
   ├── 目标：RPC 调用正常
   └── 场景：注册、心跳、连接池等

3. 压力测试（专业工具）
   ├── HTTP/gRPC：
   │   ├── wrk（HTTP 压测）
   │   ├── ghz（gRPC 压测）
   │   └── 目标：QPS、延迟、并发
   │
   ├── 自定义场景：
   │   ├── 模拟玩家登录/登出
   │   ├── 模拟游戏操作
   │   └── 模拟文件上传/下载
   │
   └── 性能指标：
       ├── QPS（每秒请求数）
       ├── 延迟（P50/P90/P99）
       ├── 错误率
       └── 资源使用（CPU/内存）

4. 监控工具（持续监控）
   ├── Prometheus + Grafana（推荐）
   ├── 项目自带的性能监控系统
   └── 实时查看各项指标
```

**压力测试示例**（使用 ghz 测试 gRPC）：
```bash
# 安装 ghz
go install github.com/bojand/ghz/cmd/ghz@latest

# 测试 Central Server 的 RegisterServer 接口
ghz --insecure \
  --proto protobuf/cpp/src/central.proto \
  --call central.CentralService/RegisterServer \
  -d '{"server_type":"LOGIN","server_address":"127.0.0.1:50052"}' \
  -n 10000 \  # 总请求数
  -c 100 \    # 并发数
  localhost:50051

# 输出示例：
# Requests: 10,000
# Duration: 5.2s
# QPS: 1923
# Latency: P50=45ms, P90=82ms, P99=150ms
```

---

### 进度管理

**Q11: 如何跟踪开发进度？**

A: **推荐使用 GitHub Projects + 本文档检查清单**：

```
推荐工具：

1. GitHub Projects（看板管理）
   ├── 创建项目看板
   ├── 设置列：Backlog, In Progress, Review, Testing, Done
   ├── 为每个任务创建 Issue
   └── 拖拽移动任务状态

2. GitHub Milestones（里程碑）
   ├── Milestone 1: 阶段 1 完成
   ├── Milestone 2: 阶段 2 完成
   ├── ...
   └── 查看完成百分比

3. 检查清单（本文档）
   ├── 每个阶段有明确的检查清单
   ├── 完成一项打钩 ✅
   └── 一目了然

4. 周报（见文档末尾模板）
   ├── 每周记录进度
   ├── 总结问题和风险
   └── 规划下周任务
```

**GitHub Projects 设置示例**：
```
看板列设置：
├── 📋 Backlog        - 待办任务
├── 🚀 In Progress    - 进行中
├── 👀 Review         - 代码审查
├── 🧪 Testing        - 测试中
└── ✅ Done           - 已完成

标签（Labels）：
├── 🔴 P0 - 紧急
├── 🟡 P1 - 高优先级
├── 🟢 P2 - 中优先级
├── ⚪ P3 - 低优先级
├── 🐛 Bug
├── ✨ Feature
└── 📚 Documentation
```

---

**Q12: 遇到困难怎么办？**

A: **多种途径获取帮助**：

```
1. 查阅项目文档（优先）
   ├── 38+ 篇完善的文档
   ├── 涵盖各个技术点
   ├── 快速开始、核心概念、API 参考
   └── 位置：docunment/ 目录

2. 搜索引擎
   ├── Google（推荐）
   ├── Stack Overflow（技术问题）
   ├── GitHub Issues（开源项目问题）
   └── 中文搜索：百度、CSDN

3. 社区求助
   ├── GitHub Issues（项目问题）
   ├── GitHub Discussions（讨论交流）
   ├── Skynet 社区（Google Groups）
   └── C++ 论坛（cppreference、Stack Overflow）

4. AI 助手（高效）
   ├── GitHub Copilot（代码补全）
   ├── ChatGPT / Claude（技术咨询）
   ├── Cursor（AI 编程助手）
   └── 适合：代码示例、概念解释、调试建议

5. 源码阅读
   ├── Skynet 官方源码
   ├── gRPC 示例代码
   └── 本项目已有的实现
```

**提问技巧**（提高获得帮助的效率）：
```
好的提问包含：
├── ✅ 明确的问题描述
├── ✅ 已经尝试的方法
├── ✅ 错误信息/日志
├── ✅ 相关代码片段
├── ✅ 环境信息（OS、编译器、版本）
└── ✅ 预期结果 vs 实际结果

避免：
├── ❌ "为什么不work？"（太笼统）
├── ❌ 不提供错误信息
├── ❌ 不说明尝试过什么
└── ❌ 截图而不是文本代码
```

---

### 学习建议

**Q13: 完全没用过 Skynet，从哪里开始？**

A: **推荐 3 周学习路径**：

```
Week 1: 基础入门（快速上手）
├── Day 1-2: 阅读 skynet_quickstart.md
│   ├── 了解 Skynet 是什么
│   ├── 理解 Actor 模型基础
│   └── 跑通 Hello World 示例
│
├── Day 3-4: 跑官方示例
│   ├── 下载 Skynet 源码
│   ├── 编译 Skynet
│   ├── 运行 examples/
│   └── 理解基本工作流程
│
└── Day 5-7: 自己写简单服务
    ├── 创建第一个服务
    ├── 学习消息传递
    └── 实践服务通信

Week 2: 深入学习（核心概念）
├── Day 1-3: 阅读 skynet_concepts.md
│   ├── 深入理解 Actor 模型
│   ├── 消息传递机制
│   ├── 服务生命周期
│   └── 时间轮（timer）
│
├── Day 4-5: 学习 Skynet API
│   ├── 阅读 skynet_api_reference.md
│   ├── skynet.call / skynet.send
│   ├── skynet.response
│   └── socket / cluster 等
│
└── Day 6-7: 实践 Echo 服务
    ├── 实现简单的 Echo 服务
    ├── 测试 C++ 调用 Lua
    └── 验证 Protobuf 通信

Week 3: 项目集成（边做边学）
├── 按照阶段 2 的计划实施
├── 实现 cpp_bridge.lua
├── 实现 cpp_gateway.lua
└── 边做边学，效果最好
```

**学习资源优先级**：
```
1. 项目文档（必读）⭐⭐⭐⭐⭐
   └── docunment/skynet/ 目录

2. Skynet 官方 Wiki（推荐）⭐⭐⭐⭐
   └── https://github.com/cloudwu/skynet/wiki

3. 云风博客（深入理解）⭐⭐⭐⭐
   └── https://blog.codingnow.com/

4. 开源项目参考（实践）⭐⭐⭐
   └── GitHub 搜索 "skynet game server"
```

---

**Q14: 需要掌握哪些前置知识？**

A: **分必须、推荐、可选三个层次**：

```
必须掌握（否则寸步难行）:
├── ✅ C++11/14 基础
│   ├── 智能指针（shared_ptr, unique_ptr）
│   ├── Lambda 表达式
│   ├── 多线程（std::thread, mutex）
│   └── 移动语义（std::move）
│
├── ✅ 基本网络编程
│   ├── TCP/IP 基础概念
│   ├── Socket 编程（了解即可）
│   └── HTTP 基础
│
├── ✅ 基本数据库操作
│   ├── SQL 基础（SELECT, INSERT, UPDATE, DELETE）
│   ├── 表设计基础
│   └── 索引概念
│
└── ✅ Linux 命令行基础
    ├── 文件操作（ls, cd, mkdir, cp, mv）
    ├── 进程管理（ps, kill）
    └── 编译工具（make, cmake）

推荐掌握（大幅提升效率）:
├── ⭐ C++17/20 新特性
│   ├── std::optional, std::variant
│   ├── Structured bindings
│   ├── if constexpr
│   └── Concepts（C++20）
│
├── ⭐ gRPC/Protobuf 使用
│   ├── Protobuf 定义语法
│   ├── gRPC 服务定义
│   └── 代码生成工具
│
├── ⭐ Docker 基础
│   ├── 镜像和容器概念
│   ├── Dockerfile 编写
│   ├── docker-compose 使用
│   └── 基本命令（run, build, ps, logs）
│
└── ⭐ Git 版本控制
    ├── 基本操作（add, commit, push, pull）
    ├── 分支管理（branch, merge）
    └── 冲突解决

可选掌握（锦上添花）:
├── 💡 Lua 语言基础
│   ├── 基本语法（初期可以边学边用）
│   └── 表（table）的使用
│
├── 💡 Redis 使用
│   ├── 基本数据结构
│   └── 常用命令
│
├── 💡 分布式系统理论
│   ├── CAP 定理
│   └── 一致性算法
│
└── 💡 性能优化技巧
    ├── 性能分析工具
    └── 缓存策略
```

**学习优先级建议**：
```
如果时间有限：
├── 1. 先掌握"必须掌握"的内容
├── 2. 边做项目边学习"推荐掌握"的内容
└── 3. "可选掌握"的内容遇到再学

如果时间充裕：
└── 系统学习所有内容，打好基础
```

---

# 开发周报模板

使用此模板记录每周进度，便于跟踪项目状态和识别问题。

```markdown
# Week X 开发周报

**日期**：YYYY-MM-DD ~ YYYY-MM-DD  
**阶段**：阶段 X  
**开发者**：[姓名]

---

## 📋 本周目标

- [ ] 任务 1：[具体描述]
- [ ] 任务 2：[具体描述]
- [ ] 任务 3：[具体描述]

---

## ✅ 实际完成

- ✅ **任务 1**：[完成情况说明]
  - 耗时：X 天
  - 产出：[代码/文档/测试]
  
- ✅ **任务 2**：[完成情况说明]
  - 耗时：X 天
  - 产出：[代码/文档/测试]
  
- ⚠️ **任务 3**：[未完成或部分完成]
  - 原因：[说明原因]
  - 剩余工作：[说明]

---

## 📈 关键指标

| 指标 | 本周 | 累计 | 目标 | 达成率 |
|------|------|------|------|--------|
| 代码行数 | +XXX | XXXX | XXXX | XX% |
| 重复代码减少 | -XXX | -XXX | -2000 | XX% |
| 单元测试覆盖率 | XX% | XX% | 60% | XX% |
| 已完成任务 | X/X | XX/XX | - | XX% |

---

## 🐛 遇到的问题

### 问题 1：[问题标题]
- **描述**：[详细描述问题]
- **影响**：[对进度的影响]
- **解决方案**：[已解决/计划中/待讨论]
- **状态**：🔴 未解决 / 🟡 进行中 / ✅ 已解决

### 问题 2：[问题标题]
- **描述**：[详细描述问题]
- **影响**：[对进度的影响]
- **解决方案**：[已解决/计划中/待讨论]
- **状态**：🔴 未解决 / 🟡 进行中 / ✅ 已解决

---

## 📝 下周计划

- [ ] 任务 1：[具体描述]（预估 X 天）
- [ ] 任务 2：[具体描述]（预估 X 天）
- [ ] 任务 3：[具体描述]（预估 X 天）

**优先级排序**：任务 1 > 任务 2 > 任务 3

---

## ⚠️ 风险提示

- ⚠️ **风险 1**：[描述] - 缓解措施：[说明]
- ⚠️ **风险 2**：[描述] - 缓解措施：[说明]
- ✅ 无重大风险

---

## 💡 收获与思考

- 学到的技术点：[说明]
- 改进建议：[说明]
- 其他思考：[说明]
```

---

### 里程碑追踪表

| 里程碑 | 计划完成时间 | 实际完成时间 | 状态 | 完成度 | 备注 |
|--------|------------|------------|------|--------|------|
| 项目启动 | Week 0 | - | ✅ 已完成 | 100% | - |
| 阶段 1 开始 | Week 1 | - | 🟡 进行中 | 0% | - |
| BaseServer 完成 | Week 1 | - | ⚪ 未开始 | 0% | - |
| ThreadManager 统一 | Week 2 | - | ⚪ 未开始 | 0% | - |
| 通用连接池完成 | Week 2 | - | ⚪ 未开始 | 0% | - |
| ConfigManager 完成 | Week 3 | - | ⚪ 未开始 | 0% | - |
| **阶段 1 完成** | **Week 3** | - | ⚪ 未开始 | 0% | **重要里程碑** |
| 阶段 2 开始 | Week 4 | - | ⚪ 未开始 | 0% | - |
| SkynetBridge 完成 | Week 5 | - | ⚪ 未开始 | 0% | - |
| cpp_gateway 完成 | Week 6 | - | ⚪ 未开始 | 0% | - |
| Protobuf 集成 | Week 6 | - | ⚪ 未开始 | 0% | - |
| Echo 服务运行 | Week 7 | - | ⚪ 未开始 | 0% | - |
| **阶段 2 完成** | **Week 7** | - | ⚪ 未开始 | 0% | **重要里程碑** |
| 阶段 3 开始 | Week 8 | - | ⚪ 未开始 | 0% | - |
| **阶段 3 完成** | **Week 10** | - | ⚪ 未开始 | 0% | - |

**图例**：
- ✅ 已完成
- 🟡 进行中
- ⚪ 未开始
- 🔴 延期/受阻

---

### KPI 指标追踪

**代码质量指标**：

| 指标 | 基线 | Week 3 | Week 7 | Week 10 | 目标 | 状态 |
|------|------|--------|--------|---------|------|------|
| 重复代码行数 | ~2000 | - | - | - | <200 | ⚪ |
| 重复代码率 | 13% | - | - | - | <2% | ⚪ |
| 代码覆盖率 | 0% | - | - | - | >60% | ⚪ |
| 编译警告数 | ? | - | - | - | 0 | ⚪ |
| 静态分析错误 | ? | - | - | - | 0 | ⚪ |

**性能指标**：

| 指标 | 基线 | Week 7 | Week 10 | 目标 | 状态 |
|------|------|--------|---------|------|------|
| RPC 调用延迟 (P99) | ? | - | - | <10ms | ⚪ |
| 并发连接数 | ? | - | - | >10,000 | ⚪ |
| QPS (Gateway) | ? | - | - | >100,000 | ⚪ |
| 内存使用 (8 服务器) | ? | - | - | <2GB | ⚪ |

**开发效率指标**：

| 指标 | 基线 | 阶段 1 后 | 目标 | 改善 |
|------|------|-----------|------|------|
| 新增服务器耗时 | 2 天 | - | 0.5 天 | -75% |
| Bug 修复耗时 | 8 处修改 | - | 1 处修改 | -87.5% |
| 代码审查耗时 | 2 小时 | - | 1 小时 | -50% |

---

## 🔧 故障排查指南

本节提供常见问题的排查步骤和解决方案。

### 编译问题

#### 问题 1：Protobuf 编译失败

**症状**：
```
fatal error: xxx.pb.h: No such file or directory
```

**排查步骤**：
```
1. 检查 Protobuf 是否正确生成
   └── 运行：scripts/proto_make_cpp.ps1 (Windows)
   └── 运行：scripts/proto_make_cpp.sh (Linux)

2. 检查生成的文件是否存在
   └── 查看：protobuf/cpp/gen/ 目录

3. 检查 CMakeLists.txt 中的 include 路径
   └── 确认包含：include_directories(protobuf/cpp/gen)

4. 清理并重新编译
   └── rm -rf build && mkdir build && cd build && cmake .. && make
```

**解决方案**：
- 确保 protoc 已安装（`protoc --version`）
- 确保 grpc_cpp_plugin 路径正确
- 检查 .proto 文件语法是否正确

---

#### 问题 2：C++20 编译错误

**症状**：
```
error: 'invoke_result' is not a member of 'std'
error: 'invoke_result_t' was not declared in this scope
```

**排查步骤**：
```
1. 检查编译器版本
   └── g++ --version (需要 GCC 10+)
   └── clang++ --version (需要 Clang 10+)
   └── cl (需要 MSVC 2019+)

2. 检查 CMakeLists.txt 设置
   └── 确认：set(CMAKE_CXX_STANDARD 20)
   └── 确认：set(CMAKE_CXX_STANDARD_REQUIRED ON)

3. 如果编译器版本不支持
   └── 升级编译器（推荐）
   └── 或降级到 C++17（修改代码）
```

**解决方案（降级到 C++17）**：
```cpp
// 修改 src/common/thread_manager.h
// 将：
template<class F, class... Args>
using invoke_result_t = typename std::invoke_result<F, Args...>::type;

// 改为：
template<class F, class... Args>
using invoke_result_t = typename std::result_of<F(Args...)>::type;

// 同时修改 CMakeLists.txt：
set(CMAKE_CXX_STANDARD 17)
```

---

#### 问题 3：gRPC 链接错误

**症状**：
```
undefined reference to `grpc::xxx'
```

**排查步骤**：
```
1. 检查 gRPC 是否正确安装
   └── pkg-config --modversion grpc++

2. 检查 CMakeLists.txt 的链接设置
   └── 确认包含：target_link_libraries(... gRPC::grpc++)

3. 检查库文件路径
   └── ldconfig -p | grep grpc (Linux)

4. 重新安装 gRPC
   └── 参考：docunment/development/环境搭建.md
```

---

### 运行时问题

#### 问题 4：连接池耗尽

**症状**：
```
Get_connection() 一直阻塞不返回
日志显示：Connection pool exhausted
```

**排查步骤**：
```
1. 检查连接释放
   └── 每个 get_connection() 必须配对 release_connection()
   └── 使用 RAII 包装器自动释放

2. 检查连接泄漏
   └── 添加日志：
       - 获取连接时：LOG("Get connection, pool size: {}", pool.size())
       - 释放连接时：LOG("Release connection, pool size: {}", pool.size())

3. 增大连接池大小（临时方案）
   └── ConnectionPool pool(20);  // 从 10 增加到 20

4. 检查死锁
   └── 使用 gdb 查看线程堆栈
   └── gdb attach <pid>
   └── (gdb) info threads
   └── (gdb) thread apply all bt
```

**解决方案**：
```cpp
// 使用 RAII 自动释放连接
class ConnectionGuard {
public:
    ConnectionGuard(ConnectionPool& pool) 
        : pool_(pool), conn_(pool.get_connection()) {}
    
    ~ConnectionGuard() {
        if (conn_) pool_.release_connection(conn_);
    }
    
    auto get() { return conn_; }
    
private:
    ConnectionPool& pool_;
    std::shared_ptr<Connection> conn_;
};

// 使用：
{
    ConnectionGuard guard(pool);
    auto conn = guard.get();
    // 使用连接...
}  // 自动释放
```

---

#### 问题 5：Skynet 通信失败

**症状**：
```
C++ 端日志：Failed to connect to Skynet
Skynet 端无连接记录
```

**排查步骤**：
```
1. 检查 Skynet 是否启动
   └── ps aux | grep skynet
   └── 查看 Skynet 日志：logs/skynet.log

2. 检查端口是否监听
   └── netstat -an | grep 8888 (Linux)
   └── netstat -an | findstr 8888 (Windows)

3. 检查防火墙
   └── sudo ufw allow 8888 (Linux)
   └── Windows: 控制面板 → 防火墙 → 入站规则

4. 检查 IP 和端口配置
   └── C++ 端：SkynetBridge("127.0.0.1", 8888)
   └── Skynet 端：socket.listen("0.0.0.0", 8888)

5. 使用 telnet 测试连接
   └── telnet 127.0.0.1 8888
```

**解决方案**：
- 确保 Skynet 的 cpp_gateway 服务已启动
- 检查配置文件中的端口是否一致
- 查看详细日志定位问题

---

#### 问题 6：RPC 调用延迟高

**症状**：
```
RPC 调用延迟超过 50ms
性能监控显示 P99 延迟 > 100ms
```

**排查步骤**：
```
1. 检查网络延迟
   └── ping 目标服务器
   └── 如果是本地：应该 <1ms

2. 查看线程池任务队列
   └── 添加监控：LOG("Task queue length: {}", queue.size())
   └── 如果队列很长 → 增加线程数

3. 检查数据库查询
   └── 开启 MySQL 慢查询日志
   └── 查看是否有慢查询
   └── 添加索引优化

4. 使用性能监控工具
   └── 查看各个服务的 CPU 使用率
   └── 查看是否有瓶颈

5. 分段测试延迟
   └── 客户端 → Gateway：X ms
   └── Gateway → Logic：Y ms
   └── Logic → DB：Z ms
   └── 定位瓶颈环节
```

**解决方案**：
```cpp
// 1. 增加线程池大小
thread_pool_.resize(16);  // 从 8 增加到 16

// 2. 优化数据库查询
// 添加索引
CREATE INDEX idx_player_id ON players(player_id);

// 3. 使用连接池
// 避免每次请求都创建新连接

// 4. 添加缓存
// 热点数据放入 Redis
```

---

#### 问题 7：内存持续增长

**症状**：
```
服务器运行一段时间后内存使用持续增长
最终可能导致 OOM (Out of Memory)
```

**排查步骤**：
```
1. 使用 Valgrind 检测内存泄漏
   └── valgrind --leak-check=full --log-file=valgrind.log ./server
   └── 查看 valgrind.log 中的泄漏报告

2. 检查智能指针循环引用
   └── 使用 weak_ptr 打破循环引用

3. 检查连接是否正确关闭
   └── 数据库连接
   └── 网络连接
   └── 文件句柄

4. 定期监控内存使用
   └── 添加日志：LOG("Memory usage: {} MB", get_memory_usage())

5. 使用内存分析工具
   └── Heaptrack (Linux)
   └── Visual Studio Profiler (Windows)
```

**解决方案**：
```cpp
// 1. 打破循环引用
class Parent {
    std::shared_ptr<Child> child_;  // 强引用
};

class Child {
    std::weak_ptr<Parent> parent_;  // 弱引用，打破循环
};

// 2. 确保资源释放
class Server {
    ~Server() {
        // 显式关闭所有连接
        if (db_conn_) db_conn_->close();
        if (redis_conn_) redis_conn_->disconnect();
    }
};

// 3. 定期清理缓存
void Server::cleanup() {
    // 清理过期的会话
    session_cache_.remove_expired();
    
    // 清理旧日志
    log_buffer_.clear_old_entries();
}
```

---

#### 问题 8：Lua 调用 C++ 服务失败

**症状**：
```lua
-- Skynet 日志
attempt to call a nil value
```

**排查步骤**：
```
1. 检查 C++ 函数是否注册到 Lua
   └── 使用 LuaManager 注册函数

2. 检查函数名是否正确
   └── Lua 端调用的名称要和注册时一致

3. 检查参数类型
   └── Lua → C++ 的类型转换是否正确

4. 查看详细错误信息
   └── 使用 pcall 捕获错误
   └── local ok, err = pcall(function() ... end)
   └── if not ok then print(err) end
```

---

#### 问题 9：Protobuf 解析失败

**症状**：
```lua
-- Skynet 日志
Failed to decode protobuf message
```

**排查步骤**：
```
1. 检查 .pb 文件是否正确加载
   └── proto.load("xxx.pb") 返回 true

2. 检查消息类型名称
   └── proto.decode("PlayerData", buffer)
   └── 类型名称必须完全匹配

3. 检查 Protobuf 版本一致性
   └── C++ 端和 Lua 端使用相同版本的 Protobuf

4. 查看原始数据
   └── print_hex(buffer)  -- 打印16进制数据
   └── 检查数据是否损坏

5. 验证 C++ 端序列化
   └── C++ 端先序列化一个已知消息
   └── Lua 端尝试解析
   └── 对比结果
```

**解决方案**：
```lua
-- 添加详细错误处理
local function safe_decode(msg_type, buffer)
    local ok, result = pcall(proto.decode, msg_type, buffer)
    if not ok then
        print("Decode failed:", result)
        print("Message type:", msg_type)
        print("Buffer size:", #buffer)
        -- 打印前100字节的hex
        print("Buffer hex:", string.format("%02x", string.byte(buffer, 1, math.min(100, #buffer))))
        return nil, result
    end
    return result
end
```

---


